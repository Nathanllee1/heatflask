V/*\u000a * Utility functions to decode/encode numbers and array's of numbers\u000a * to/from strings (Google maps polyline encoding)\u000a *\u000a * Extends the L.Polyline and L.Polygon object with methods to convert\u000a * to and create from these strings.\u000a *\u000a * Jan Pieter Waagmeester <jieter@jieter.nl>\u000a *\u000a * Original code from:\u000a * http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/\u000a * (which is down as of december 2014)\u000a */\u000a\u000a(function () {\u000a    'use strict';\u000a\u000a    var defaultOptions = function (options) {\u000a        if (typeof options === 'number') {\u000a            // Legacy\u000a            options = {\u000a                precision: options\u000a            };\u000a        } else {\u000a            options = options || {};\u000a        }\u000a\u000a        options.precision = options.precision || 5;\u000a        options.factor = options.factor || Math.pow(10, options.precision);\u000a        options.dimension = options.dimension || 2;\u000a        return options;\u000a    };\u000a\u000a    var PolylineUtil = {\u000a        encode: function (points, options) {\u000a            options = defaultOptions(options);\u000a\u000a            var flatPoints = [];\u000a            for (var i = 0, len = points.length; i < len; ++i) {\u000a                var point = points[i];\u000a\u000a                if (options.dimension === 2) {\u000a                    flatPoints.push(point.lat || point[0]);\u000a                    flatPoints.push(point.lng || point[1]);\u000a                } else {\u000a                    for (var dim = 0; dim < options.dimension; ++dim) {\u000a                        flatPoints.push(point[dim]);\u000a                    }\u000a                }\u000a            }\u000a\u000a            return this.encodeDeltas(flatPoints, options);\u000a        },\u000a\u000a        decode: function (encoded, options) {\u000a            options = defaultOptions(options);\u000a\u000a            var flatPoints = this.decodeDeltas(encoded, options);\u000a\u000a            var points = [];\u000a            for (var i = 0, len = flatPoints.length; i + (options.dimension - 1) < len;) {\u000a                var point = [];\u000a\u000a                for (var dim = 0; dim < options.dimension; ++dim) {\u000a                    point.push(flatPoints[i++]);\u000a                }\u000a\u000a                points.push(point);\u000a            }\u000a\u000a            return points;\u000a        },\u000a\u000a        encodeDeltas: function (numbers, options) {\u000a            options = defaultOptions(options);\u000a\u000a            var lastNumbers = [];\u000a\u000a            for (var i = 0, len = numbers.length; i < len;) {\u000a                for (var d = 0; d < options.dimension; ++d, ++i) {\u000a                    var num = numbers[i];\u000a                    var delta = num - (lastNumbers[d] || 0);\u000a                    lastNumbers[d] = num;\u000a\u000a                    numbers[i] = delta;\u000a                }\u000a            }\u000a\u000a            return this.encodeFloats(numbers, options);\u000a        },\u000a\u000a        decodeDeltas: function (encoded, options) {\u000a            options = defaultOptions(options);\u000a\u000a            var lastNumbers = [];\u000a\u000a            var numbers = this.decodeFloats(encoded, options);\u000a            for (var i = 0, len = numbers.length; i < len;) {\u000a                for (var d = 0; d < options.dimension; ++d, ++i) {\u000a                    numbers[i] = Math.round((lastNumbers[d] = numbers[i] + (lastNumbers[d] || 0)) * options.factor) / options.factor;\u000a                }\u000a            }\u000a\u000a            return numbers;\u000a        },\u000a\u000a        encodeFloats: function (numbers, options) {\u000a            options = defaultOptions(options);\u000a\u000a            for (var i = 0, len = numbers.length; i < len; ++i) {\u000a                numbers[i] = Math.round(numbers[i] * options.factor);\u000a            }\u000a\u000a            return this.encodeSignedIntegers(numbers);\u000a        },\u000a\u000a        decodeFloats: function (encoded, options) {\u000a            options = defaultOptions(options);\u000a\u000a            var numbers = this.decodeSignedIntegers(encoded);\u000a            for (var i = 0, len = numbers.length; i < len; ++i) {\u000a                numbers[i] /= options.factor;\u000a            }\u000a\u000a            return numbers;\u000a        },\u000a\u000a        encodeSignedIntegers: function (numbers) {\u000a            for (var i = 0, len = numbers.length; i < len; ++i) {\u000a                var num = numbers[i];\u000a                numbers[i] = num < 0 ? ~(num << 1) : num << 1;\u000a            }\u000a\u000a            return this.encodeUnsignedIntegers(numbers);\u000a        },\u000a\u000a        decodeSignedIntegers: function (encoded) {\u000a            var numbers = this.decodeUnsignedIntegers(encoded);\u000a\u000a            for (var i = 0, len = numbers.length; i < len; ++i) {\u000a                var num = numbers[i];\u000a                numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\u000a            }\u000a\u000a            return numbers;\u000a        },\u000a\u000a        encodeUnsignedIntegers: function (numbers) {\u000a            var encoded = '';\u000a            for (var i = 0, len = numbers.length; i < len; ++i) {\u000a                encoded += this.encodeUnsignedInteger(numbers[i]);\u000a            }\u000a            return encoded;\u000a        },\u000a\u000a        decodeUnsignedIntegers: function (encoded) {\u000a            var numbers = [];\u000a\u000a            var current = 0;\u000a            var shift = 0;\u000a\u000a            for (var i = 0, len = encoded.length; i < len; ++i) {\u000a                var b = encoded.charCodeAt(i) - 63;\u000a\u000a                current |= (b & 0x1f) << shift;\u000a\u000a                if (b < 0x20) {\u000a                    numbers.push(current);\u000a                    current = 0;\u000a                    shift = 0;\u000a                } else {\u000a                    shift += 5;\u000a                }\u000a            }\u000a\u000a            return numbers;\u000a        },\u000a\u000a        encodeSignedInteger: function (num) {\u000a            num = num < 0 ? ~(num << 1) : num << 1;\u000a            return this.encodeUnsignedInteger(num);\u000a        },\u000a\u000a        // This function is very similar to Google's, but I added\u000a        // some stuff to deal with the double slash issue.\u000a        encodeUnsignedInteger: function (num) {\u000a            var value,\u000a                encoded = '';\u000a            while (num >= 0x20) {\u000a                value = (0x20 | num & 0x1f) + 63;\u000a                encoded += String.fromCharCode(value);\u000a                num >>= 5;\u000a            }\u000a            value = num + 63;\u000a            encoded += String.fromCharCode(value);\u000a\u000a            return encoded;\u000a        }\u000a    };\u000a\u000a    // Export Node module\u000a    if (typeof module === 'object' && typeof module.exports === 'object') {\u000a        module.exports = PolylineUtil;\u000a    }\u000a\u000a    // Inject functionality into Leaflet\u000a    if (typeof L === 'object') {\u000a        if (!L.Polyline.prototype.fromEncoded) {\u000a            L.Polyline.fromEncoded = function (encoded, options) {\u000a                return L.polyline(PolylineUtil.decode(encoded), options);\u000a            };\u000a        }\u000a        if (!L.Polygon.prototype.fromEncoded) {\u000a            L.Polygon.fromEncoded = function (encoded, options) {\u000a                return L.polygon(PolylineUtil.decode(encoded), options);\u000a            };\u000a        }\u000a\u000a        var encodeMixin = {\u000a            encodePath: function () {\u000a                return PolylineUtil.encode(this.getLatLngs());\u000a            }\u000a        };\u000a\u000a        if (!L.Polyline.prototype.encodePath) {\u000a            L.Polyline.include(encodeMixin);\u000a        }\u000a        if (!L.Polygon.prototype.encodePath) {\u000a            L.Polygon.include(encodeMixin);\u000a        }\u000a\u000a        L.PolylineUtil = PolylineUtil;\u000a    }\u000a})();\u000a\u000a
p1
.