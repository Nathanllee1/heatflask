V;(function () {\u000a\u000a	"use strict";\u000a\u000a	var objectTypes = {\u000a		'function': true,\u000a		'object': true\u000a	};\u000a\u000a	function checkGlobal(value) {\u000a		return value && value.Object === Object ? value : null;\u000a	}\u000a\u000a	/** Built-in method references without a dependency on `root`. */\u000a	var freeParseFloat = parseFloat,\u000a	    freeParseInt = parseInt;\u000a\u000a	/** Detect free variable `exports`. */\u000a	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined;\u000a\u000a	/** Detect free variable `module`. */\u000a	var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined;\u000a\u000a	/** Detect the popular CommonJS extension `module.exports`. */\u000a	var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined;\u000a\u000a	/** Detect free variable `global` from Node.js. */\u000a	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);\u000a\u000a	/** Detect free variable `self`. */\u000a	var freeSelf = checkGlobal(objectTypes[typeof self] && self);\u000a\u000a	/** Detect free variable `window`. */\u000a	var freeWindow = checkGlobal(objectTypes[typeof window] && window);\u000a\u000a	/** Detect `this` as the global object. */\u000a	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\u000a\u000a	/**\u000a * Used as a reference to the global object.\u000a *\u000a * The `this` value is used if it's the global object to avoid Greasemonkey's\u000a * restricted `window` object, otherwise the `window` object is used.\u000a */\u000a	var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();\u000a\u000a	if (!('gc' in window)) {\u000a		window.gc = function () {};\u000a	}\u000a\u000a	if (!HTMLCanvasElement.prototype.toBlob) {\u000a		Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\u000a			value: function (callback, type, quality) {\u000a\u000a				var binStr = atob(this.toDataURL(type, quality).split(',')[1]),\u000a				    len = binStr.length,\u000a				    arr = new Uint8Array(len);\u000a\u000a				for (var i = 0; i < len; i++) {\u000a					arr[i] = binStr.charCodeAt(i);\u000a				}\u000a\u000a				callback(new Blob([arr], { type: type || 'image/png' }));\u000a			}\u000a		});\u000a	}\u000a\u000a	// @license http://opensource.org/licenses/MIT\u000a	// copyright Paul Irish 2015\u000a\u000a\u000a	// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\u000a	//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\u000a	// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\u000a\u000a	// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\u000a	// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\u000a\u000a\u000a	(function () {\u000a\u000a		if ("performance" in window == false) {\u000a			window.performance = {};\u000a		}\u000a\u000a		Date.now = Date.now || function () {\u000a			// thanks IE8\u000a			return new Date().getTime();\u000a		};\u000a\u000a		if ("now" in window.performance == false) {\u000a\u000a			var nowOffset = Date.now();\u000a\u000a			if (performance.timing && performance.timing.navigationStart) {\u000a				nowOffset = performance.timing.navigationStart;\u000a			}\u000a\u000a			window.performance.now = function now() {\u000a				return Date.now() - nowOffset;\u000a			};\u000a		}\u000a	})();\u000a\u000a	function pad(n) {\u000a		return String("0000000" + n).slice(-7);\u000a	}\u000a	// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\u000a\u000a	var g_startTime = window.Date.now();\u000a\u000a	function guid() {\u000a		function s4() {\u000a			return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\u000a		}\u000a		return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\u000a	}\u000a\u000a	function CCFrameEncoder(settings) {\u000a\u000a		var _handlers = {};\u000a\u000a		this.settings = settings;\u000a\u000a		this.on = function (event, handler) {\u000a\u000a			_handlers[event] = handler;\u000a		};\u000a\u000a		this.emit = function (event) {\u000a\u000a			var handler = _handlers[event];\u000a			if (handler) {\u000a\u000a				handler.apply(null, Array.prototype.slice.call(arguments, 1));\u000a			}\u000a		};\u000a\u000a		this.filename = settings.name || guid();\u000a		this.extension = '';\u000a		this.mimeType = '';\u000a	}\u000a\u000a	CCFrameEncoder.prototype.start = function () {};\u000a	CCFrameEncoder.prototype.stop = function () {};\u000a	CCFrameEncoder.prototype.add = function () {};\u000a	CCFrameEncoder.prototype.save = function () {};\u000a	CCFrameEncoder.prototype.dispose = function () {};\u000a	CCFrameEncoder.prototype.safeToProceed = function () {\u000a		return true;\u000a	};\u000a	CCFrameEncoder.prototype.step = function () {\u000a		console.log('Step not set!');\u000a	};\u000a\u000a	function CCTarEncoder(settings) {\u000a\u000a		CCFrameEncoder.call(this, settings);\u000a\u000a		this.extension = '.tar';\u000a		this.mimeType = 'application/x-tar';\u000a		this.fileExtension = '';\u000a\u000a		this.tape = null;\u000a		this.count = 0;\u000a	}\u000a\u000a	CCTarEncoder.prototype = Object.create(CCFrameEncoder.prototype);\u000a\u000a	CCTarEncoder.prototype.start = function () {\u000a\u000a		this.dispose();\u000a	};\u000a\u000a	CCTarEncoder.prototype.add = function (blob) {\u000a\u000a		var fileReader = new FileReader();\u000a		fileReader.onload = function () {\u000a			this.tape.append(pad(this.count) + this.fileExtension, new Uint8Array(fileReader.result));\u000a\u000a			//if( this.settings.autoSaveTime > 0 && ( this.frames.length / this.settings.framerate ) >= this.settings.autoSaveTime ) {\u000a\u000a			this.count++;\u000a			this.step();\u000a		}.bind(this);\u000a		fileReader.readAsArrayBuffer(blob);\u000a	};\u000a\u000a	CCTarEncoder.prototype.save = function (callback) {\u000a\u000a		callback(this.tape.save());\u000a	};\u000a\u000a	CCTarEncoder.prototype.dispose = function () {\u000a\u000a		this.tape = new Tar();\u000a		this.count = 0;\u000a	};\u000a\u000a	function CCPNGEncoder(settings) {\u000a\u000a		CCTarEncoder.call(this, settings);\u000a\u000a		this.type = 'image/png';\u000a		this.fileExtension = '.png';\u000a	}\u000a\u000a	CCPNGEncoder.prototype = Object.create(CCTarEncoder.prototype);\u000a\u000a	CCPNGEncoder.prototype.add = function (canvas) {\u000a\u000a		canvas.toBlob(function (blob) {\u000a			CCTarEncoder.prototype.add.call(this, blob);\u000a		}.bind(this), this.type);\u000a	};\u000a\u000a	function CCJPEGEncoder(settings) {\u000a\u000a		CCTarEncoder.call(this, settings);\u000a\u000a		this.type = 'image/jpeg';\u000a		this.fileExtension = '.jpg';\u000a		this.quality = settings.quality / 100 || .8;\u000a	}\u000a\u000a	CCJPEGEncoder.prototype = Object.create(CCTarEncoder.prototype);\u000a\u000a	CCJPEGEncoder.prototype.add = function (canvas) {\u000a\u000a		canvas.toBlob(function (blob) {\u000a			CCTarEncoder.prototype.add.call(this, blob);\u000a		}.bind(this), this.type, this.quality);\u000a	};\u000a\u000a	/*\u000a \u000a 	WebM Encoder\u000a \u000a */\u000a\u000a	function CCWebMEncoder(settings) {\u000a\u000a		var canvas = document.createElement('canvas');\u000a		if (canvas.toDataURL('image/webp').substr(5, 10) !== 'image/webp') {\u000a			console.log("WebP not supported - try another export format");\u000a		}\u000a\u000a		CCFrameEncoder.call(this, settings);\u000a\u000a		settings.quality = settings.quality / 100 || .8;\u000a\u000a		this.extension = '.webm';\u000a		this.mimeType = 'video/webm';\u000a		this.baseFilename = this.filename;\u000a\u000a		this.frames = [];\u000a		this.part = 1;\u000a	}\u000a\u000a	CCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);\u000a\u000a	CCWebMEncoder.prototype.start = function (canvas) {\u000a\u000a		this.dispose();\u000a	};\u000a\u000a	CCWebMEncoder.prototype.add = function (canvas) {\u000a\u000a		this.frames.push(canvas.toDataURL('image/webp', this.quality));\u000a\u000a		if (this.settings.autoSaveTime > 0 && this.frames.length / this.settings.framerate >= this.settings.autoSaveTime) {\u000a			this.save(function (blob) {\u000a				this.filename = this.baseFilename + '-part-' + pad(this.part);\u000a				download(blob, this.filename + this.extension, this.mimeType);\u000a				this.dispose();\u000a				this.part++;\u000a				this.filename = this.baseFilename + '-part-' + pad(this.part);\u000a				this.step();\u000a			}.bind(this));\u000a		} else {\u000a			this.step();\u000a		}\u000a	};\u000a\u000a	CCWebMEncoder.prototype.save = function (callback) {\u000a\u000a		if (!this.frames.length) return;\u000a\u000a		var webm = Whammy.fromImageArray(this.frames, this.settings.framerate);\u000a		var blob = new Blob([webm], { type: "octet/stream" });\u000a		callback(blob);\u000a	};\u000a\u000a	CCWebMEncoder.prototype.dispose = function (canvas) {\u000a\u000a		this.frames = [];\u000a	};\u000a\u000a	function CCFFMpegServerEncoder(settings) {\u000a\u000a		CCFrameEncoder.call(this, settings);\u000a\u000a		settings.quality = settings.quality / 100 || .8;\u000a\u000a		this.encoder = new FFMpegServer.Video(settings);\u000a		this.encoder.on('process', function () {\u000a			this.emit('process');\u000a		}.bind(this));\u000a		this.encoder.on('finished', function (url, size) {\u000a			var cb = this.callback;\u000a			if (cb) {\u000a				this.callback = undefined;\u000a				cb(url, size);\u000a			}\u000a		}.bind(this));\u000a		this.encoder.on('progress', function (progress) {\u000a			if (this.settings.onProgress) {\u000a				this.settings.onProgress(progress);\u000a			}\u000a		}.bind(this));\u000a		this.encoder.on('error', function (data) {\u000a			alert(JSON.stringify(data, null, 2));\u000a		}.bind(this));\u000a	}\u000a\u000a	CCFFMpegServerEncoder.prototype = Object.create(CCFrameEncoder.prototype);\u000a\u000a	CCFFMpegServerEncoder.prototype.start = function () {\u000a\u000a		this.encoder.start(this.settings);\u000a	};\u000a\u000a	CCFFMpegServerEncoder.prototype.add = function (canvas) {\u000a\u000a		this.encoder.add(canvas);\u000a	};\u000a\u000a	CCFFMpegServerEncoder.prototype.save = function (callback) {\u000a\u000a		this.callback = callback;\u000a		this.encoder.end();\u000a	};\u000a\u000a	CCFFMpegServerEncoder.prototype.safeToProceed = function () {\u000a		return this.encoder.safeToProceed();\u000a	};\u000a\u000a	/*\u000a 	HTMLCanvasElement.captureStream()\u000a */\u000a\u000a	function CCStreamEncoder(settings) {\u000a\u000a		CCFrameEncoder.call(this, settings);\u000a\u000a		this.framerate = this.settings.framerate;\u000a		this.type = 'video/webm';\u000a		this.extension = '.webm';\u000a		this.stream = null;\u000a		this.mediaRecorder = null;\u000a		this.chunks = [];\u000a	}\u000a\u000a	CCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);\u000a\u000a	CCStreamEncoder.prototype.add = function (canvas) {\u000a\u000a		if (!this.stream) {\u000a			this.stream = canvas.captureStream(this.framerate);\u000a			this.mediaRecorder = new MediaRecorder(this.stream);\u000a			this.mediaRecorder.start();\u000a\u000a			this.mediaRecorder.ondataavailable = function (e) {\u000a				this.chunks.push(e.data);\u000a			}.bind(this);\u000a		}\u000a		this.step();\u000a	};\u000a\u000a	CCStreamEncoder.prototype.save = function (callback) {\u000a\u000a		this.mediaRecorder.onstop = function (e) {\u000a			var blob = new Blob(this.chunks, { 'type': 'video/webm' });\u000a			this.chunks = [];\u000a			callback(blob);\u000a		}.bind(this);\u000a\u000a		this.mediaRecorder.stop();\u000a	};\u000a\u000a	function CCGIFEncoder(settings) {\u000a\u000a		CCFrameEncoder.call(this, settings);\u000a\u000a		settings.quality = 31 - (settings.quality * 30 / 100 || 10);\u000a		settings.workers = settings.workers || 4;\u000a\u000a		this.extension = '.gif';\u000a		this.mimeType = 'image/gif';\u000a\u000a		this.canvas = document.createElement('canvas');\u000a		this.ctx = this.canvas.getContext('2d');\u000a		this.sizeSet = false;\u000a\u000a		this.encoder = new GIF({\u000a			workers: settings.workers,\u000a			quality: settings.quality,\u000a			background: "#FFFF",\u000a			workerScript: settings.workersPath + 'gif.worker.js'\u000a		});\u000a\u000a		this.encoder.on('progress', function (progress) {\u000a			if (this.settings.onProgress) {\u000a				this.settings.onProgress(progress);\u000a			}\u000a		}.bind(this));\u000a\u000a		this.encoder.on('finished', function (blob) {\u000a			var cb = this.callback;\u000a			if (cb) {\u000a				this.callback = undefined;\u000a				cb(blob);\u000a			}\u000a		}.bind(this));\u000a	}\u000a\u000a	CCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);\u000a\u000a	CCGIFEncoder.prototype.add = function (canvas) {\u000a\u000a		if (!this.sizeSet) {\u000a			this.encoder.setOption('width', canvas.width);\u000a			this.encoder.setOption('height', canvas.height);\u000a			this.sizeSet = true;\u000a		}\u000a\u000a		this.canvas.width = canvas.width;\u000a		this.canvas.height = canvas.height;\u000a		this.ctx.drawImage(canvas, 0, 0);\u000a\u000a		this.encoder.addFrame(this.ctx, { copy: true, delay: this.settings.step });\u000a		this.step();\u000a	};\u000a\u000a	CCGIFEncoder.prototype.save = function (callback) {\u000a\u000a		this.callback = callback;\u000a\u000a		this.encoder.render();\u000a	};\u000a\u000a	function CCapture(settings) {\u000a\u000a		var _settings = settings || {},\u000a		    _date = new Date(),\u000a		    _verbose,\u000a		    _display,\u000a		    _time,\u000a		    _startTime,\u000a		    _performanceTime,\u000a		    _performanceStartTime,\u000a		    _step,\u000a		    _encoder,\u000a		    _timeouts = [],\u000a		    _intervals = [],\u000a		    _frameCount = 0,\u000a		    _intermediateFrameCount = 0,\u000a		    _lastFrame = null,\u000a		    _requestAnimationFrameCallbacks = [],\u000a		    _capturing = false,\u000a		    _handlers = {};\u000a\u000a		_settings.framerate = _settings.framerate || 60;\u000a		_settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);\u000a		_verbose = _settings.verbose || false;\u000a		_display = _settings.display || false;\u000a		_settings.step = 1000.0 / _settings.framerate;\u000a		_settings.timeLimit = _settings.timeLimit || 0;\u000a		_settings.frameLimit = _settings.frameLimit || 0;\u000a		_settings.startTime = _settings.startTime || 0;\u000a\u000a		var _timeDisplay = document.createElement('div');\u000a		_timeDisplay.style.position = 'absolute';\u000a		_timeDisplay.style.left = _timeDisplay.style.top = 0;\u000a		_timeDisplay.style.backgroundColor = 'black';\u000a		_timeDisplay.style.fontFamily = 'monospace';\u000a		_timeDisplay.style.fontSize = '11px';\u000a		_timeDisplay.style.padding = '5px';\u000a		_timeDisplay.style.color = 'red';\u000a		_timeDisplay.style.zIndex = 100000;\u000a		if (_settings.display) document.body.appendChild(_timeDisplay);\u000a\u000a		var canvasMotionBlur = document.createElement('canvas');\u000a		var ctxMotionBlur = canvasMotionBlur.getContext('2d');\u000a		var bufferMotionBlur;\u000a		var imageData;\u000a\u000a		_log('Step is set to ' + _settings.step + 'ms');\u000a\u000a		var _encoders = {\u000a			gif: CCGIFEncoder,\u000a			webm: CCWebMEncoder,\u000a			ffmpegserver: CCFFMpegServerEncoder,\u000a			png: CCPNGEncoder,\u000a			jpg: CCJPEGEncoder,\u000a			'webm-mediarecorder': CCStreamEncoder\u000a		};\u000a\u000a		var ctor = _encoders[_settings.format];\u000a		if (!ctor) {\u000a			throw "Error: Incorrect or missing format: Valid formats are " + Object.keys(_encoders).join(", ");\u000a		}\u000a		_encoder = new ctor(_settings);\u000a		_encoder.step = _step;\u000a\u000a		_encoder.on('process', _process);\u000a		_encoder.on('progress', _progress);\u000a\u000a		if ("performance" in window == false) {\u000a			window.performance = {};\u000a		}\u000a\u000a		Date.now = Date.now || function () {\u000a			// thanks IE8\u000a			return new Date().getTime();\u000a		};\u000a\u000a		if ("now" in window.performance == false) {\u000a\u000a			var nowOffset = Date.now();\u000a\u000a			if (performance.timing && performance.timing.navigationStart) {\u000a				nowOffset = performance.timing.navigationStart;\u000a			}\u000a\u000a			window.performance.now = function now() {\u000a				return Date.now() - nowOffset;\u000a			};\u000a		}\u000a\u000a		var _oldSetTimeout = window.setTimeout,\u000a		    _oldSetInterval = window.setInterval,\u000a		    _oldClearTimeout = window.clearTimeout,\u000a		    _oldRequestAnimationFrame = window.requestAnimationFrame,\u000a		    _oldNow = window.Date.now,\u000a		    _oldPerformanceNow = window.performance.now,\u000a		    _oldGetTime = window.Date.prototype.getTime;\u000a		// Date.prototype._oldGetTime = Date.prototype.getTime;\u000a\u000a		var media = [];\u000a\u000a		function _init() {\u000a\u000a			_log('Capturer start');\u000a\u000a			_startTime = window.Date.now();\u000a			_time = _startTime + _settings.startTime;\u000a			_performanceStartTime = window.performance.now();\u000a			_performanceTime = _performanceStartTime + _settings.startTime;\u000a\u000a			window.Date.prototype.getTime = function () {\u000a				return _time;\u000a			};\u000a			window.Date.now = function () {\u000a				return _time;\u000a			};\u000a\u000a			window.setTimeout = function (callback, time) {\u000a				var t = {\u000a					callback: callback,\u000a					time: time,\u000a					triggerTime: _time + time\u000a				};\u000a				_timeouts.push(t);\u000a				_log('Timeout set to ' + t.time);\u000a				return t;\u000a			};\u000a			window.clearTimeout = function (id) {\u000a				for (var j = 0; j < _timeouts.length; j++) {\u000a					if (_timeouts[j] == id) {\u000a						_timeouts.splice(j, 1);\u000a						_log('Timeout cleared');\u000a						continue;\u000a					}\u000a				}\u000a			};\u000a			window.setInterval = function (callback, time) {\u000a				var t = {\u000a					callback: callback,\u000a					time: time,\u000a					triggerTime: _time + time\u000a				};\u000a				_intervals.push(t);\u000a				_log('Interval set to ' + t.time);\u000a				return t;\u000a			};\u000a			window.clearInterval = function (id) {\u000a				_log('clear Interval');\u000a				return null;\u000a			};\u000a			window.requestAnimationFrame = function (callback) {\u000a				_requestAnimationFrameCallbacks.push(callback);\u000a			};\u000a			window.performance.now = function () {\u000a				return _performanceTime;\u000a			};\u000a\u000a			function hookCurrentTime() {\u000a				if (!this._hooked) {\u000a					this._hooked = true;\u000a					this._hookedTime = this.currentTime || 0;\u000a					this.pause();\u000a					media.push(this);\u000a				}\u000a				return this._hookedTime + _settings.startTime;\u000a			};\u000a\u000a			try {\u000a				Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', { get: hookCurrentTime });\u000a				Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', { get: hookCurrentTime });\u000a			} catch (err) {\u000a				_log(err);\u000a			}\u000a		}\u000a\u000a		function _start() {\u000a			_init();\u000a			_encoder.start();\u000a			_capturing = true;\u000a		}\u000a\u000a		function _stop() {\u000a			_capturing = false;\u000a			_encoder.stop();\u000a			_destroy();\u000a		}\u000a\u000a		function _call(fn, p) {\u000a			_oldSetTimeout(fn, 0, p);\u000a		}\u000a\u000a		function _step() {\u000a			//_oldRequestAnimationFrame( _process );\u000a			_call(_process);\u000a		}\u000a\u000a		function _destroy() {\u000a			_log('Capturer stop');\u000a			window.setTimeout = _oldSetTimeout;\u000a			window.setInterval = _oldSetInterval;\u000a			window.clearTimeout = _oldClearTimeout;\u000a			window.requestAnimationFrame = _oldRequestAnimationFrame;\u000a			window.Date.prototype.getTime = _oldGetTime;\u000a			window.Date.now = _oldNow;\u000a			window.performance.now = _oldPerformanceNow;\u000a		}\u000a\u000a		function _updateTime() {\u000a			var seconds = _frameCount / _settings.framerate;\u000a			if (_settings.frameLimit && _frameCount >= _settings.frameLimit || _settings.timeLimit && seconds >= _settings.timeLimit) {\u000a				_stop();\u000a				_save();\u000a			}\u000a			var d = new Date(null);\u000a			d.setSeconds(seconds);\u000a			if (_settings.motionBlurFrames > 2) {\u000a				_timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames (' + _intermediateFrameCount + ' inter) | ' + d.toISOString().substr(11, 8);\u000a			} else {\u000a				_timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames | ' + d.toISOString().substr(11, 8);\u000a			}\u000a		}\u000a\u000a		function _checkFrame(canvas) {\u000a\u000a			if (canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height) {\u000a				canvasMotionBlur.width = canvas.width;\u000a				canvasMotionBlur.height = canvas.height;\u000a				bufferMotionBlur = new Uint16Array(canvasMotionBlur.height * canvasMotionBlur.width * 4);\u000a				ctxMotionBlur.fillStyle = '#0';\u000a				ctxMotionBlur.fillRect(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\u000a			}\u000a		}\u000a\u000a		function _blendFrame(canvas) {\u000a\u000a			//_log( 'Intermediate Frame: ' + _intermediateFrameCount );\u000a\u000a			ctxMotionBlur.drawImage(canvas, 0, 0);\u000a			imageData = ctxMotionBlur.getImageData(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\u000a			for (var j = 0; j < bufferMotionBlur.length; j += 4) {\u000a				bufferMotionBlur[j] += imageData.data[j];\u000a				bufferMotionBlur[j + 1] += imageData.data[j + 1];\u000a				bufferMotionBlur[j + 2] += imageData.data[j + 2];\u000a			}\u000a			_intermediateFrameCount++;\u000a		}\u000a\u000a		function _saveFrame() {\u000a\u000a			var data = imageData.data;\u000a			for (var j = 0; j < bufferMotionBlur.length; j += 4) {\u000a				data[j] = bufferMotionBlur[j] * 2 / _settings.motionBlurFrames;\u000a				data[j + 1] = bufferMotionBlur[j + 1] * 2 / _settings.motionBlurFrames;\u000a				data[j + 2] = bufferMotionBlur[j + 2] * 2 / _settings.motionBlurFrames;\u000a			}\u000a			ctxMotionBlur.putImageData(imageData, 0, 0);\u000a			_encoder.add(canvasMotionBlur);\u000a			_frameCount++;\u000a			_intermediateFrameCount = 0;\u000a			_log('Full MB Frame! ' + _frameCount + ' ' + _time);\u000a			for (var j = 0; j < bufferMotionBlur.length; j += 4) {\u000a				bufferMotionBlur[j] = 0;\u000a				bufferMotionBlur[j + 1] = 0;\u000a				bufferMotionBlur[j + 2] = 0;\u000a			}\u000a			gc();\u000a		}\u000a\u000a		function _capture(canvas) {\u000a\u000a			if (_capturing) {\u000a\u000a				if (_settings.motionBlurFrames > 2) {\u000a\u000a					_checkFrame(canvas);\u000a					_blendFrame(canvas);\u000a\u000a					if (_intermediateFrameCount >= .5 * _settings.motionBlurFrames) {\u000a						_saveFrame();\u000a					} else {\u000a						_step();\u000a					}\u000a				} else {\u000a					_encoder.add(canvas);\u000a					_frameCount++;\u000a					_log('Full Frame! ' + _frameCount);\u000a				}\u000a			}\u000a		}\u000a\u000a		function _process() {\u000a\u000a			var step = 1000 / _settings.framerate;\u000a			var dt = (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) * step;\u000a\u000a			_time = _startTime + dt;\u000a			_performanceTime = _performanceStartTime + dt;\u000a\u000a			media.forEach(function (v) {\u000a				v._hookedTime = dt / 1000;\u000a			});\u000a\u000a			_updateTime();\u000a			_log('Frame: ' + _frameCount + ' ' + _intermediateFrameCount);\u000a\u000a			for (var j = 0; j < _timeouts.length; j++) {\u000a				if (_time >= _timeouts[j].triggerTime) {\u000a					_call(_timeouts[j].callback);\u000a					//console.log( 'timeout!' );\u000a					_timeouts.splice(j, 1);\u000a					continue;\u000a				}\u000a			}\u000a\u000a			for (var j = 0; j < _intervals.length; j++) {\u000a				if (_time >= _intervals[j].triggerTime) {\u000a					_call(_intervals[j].callback);\u000a					_intervals[j].triggerTime += _intervals[j].time;\u000a					//console.log( 'interval!' );\u000a					continue;\u000a				}\u000a			}\u000a\u000a			_requestAnimationFrameCallbacks.forEach(function (cb) {\u000a				_call(cb, _time - g_startTime);\u000a			});\u000a			_requestAnimationFrameCallbacks = [];\u000a		}\u000a\u000a		function _save(callback) {\u000a\u000a			if (!callback) {\u000a				callback = function (blob) {\u000a					download(blob, _encoder.filename + _encoder.extension, _encoder.mimeType);\u000a					return false;\u000a				};\u000a			}\u000a			_encoder.save(callback);\u000a		}\u000a\u000a		function _log(message) {\u000a			if (_verbose) console.log(message);\u000a		}\u000a\u000a		function _on(event, handler) {\u000a\u000a			_handlers[event] = handler;\u000a		}\u000a\u000a		function _emit(event) {\u000a\u000a			var handler = _handlers[event];\u000a			if (handler) {\u000a\u000a				handler.apply(null, Array.prototype.slice.call(arguments, 1));\u000a			}\u000a		}\u000a\u000a		function _progress(progress) {\u000a\u000a			_emit('progress', progress);\u000a		}\u000a\u000a		return {\u000a			start: _start,\u000a			capture: _capture,\u000a			stop: _stop,\u000a			save: _save,\u000a			on: _on\u000a		};\u000a	}\u000a\u000a	(freeWindow || freeSelf || {}).CCapture = CCapture;\u000a\u000a	// Some AMD build optimizers like r.js check for condition patterns like the following:\u000a	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\u000a		// Define as an anonymous module so, through path mapping, it can be\u000a		// referenced as the "underscore" module.\u000a		define(function () {\u000a			return CCapture;\u000a		});\u000a	}\u000a	// Check for `exports` after `define` in case a build optimizer adds an `exports` object.\u000a	else if (freeExports && freeModule) {\u000a			// Export for Node.js.\u000a			if (moduleExports) {\u000a				(freeModule.exports = CCapture).CCapture = CCapture;\u000a			}\u000a			// Export for CommonJS support.\u000a			freeExports.CCapture = CCapture;\u000a		} else {\u000a			// Export to the global object.\u000a			root.CCapture = CCapture;\u000a		}\u000a})();\u000a\u000a
p1
.