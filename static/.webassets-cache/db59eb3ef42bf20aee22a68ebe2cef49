V/*\u000a  DotLayer Efrem Rensi, 2017,\u000a  based on L.CanvasLayer by Stanislav Sumbera,  2016 , sumbera.com\u000a  license MIT\u000a*/\u000a\u000a// -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7\u000a//------------------------------------------------------------------------------\u000aL.DomUtil.setTransform = L.DomUtil.setTransform || function (el, offset, scale) {\u000a    var pos = offset || new L.Point(0, 0);\u000a\u000a    el.style[L.DomUtil.TRANSFORM] = (L.Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");\u000a};\u000a\u000a// -- support for both  0.0.7 and 1.0.0 rc2 leaflet\u000aL.DotLayer = (L.Layer ? L.Layer : L.Class).extend({\u000a\u000a    _pane: "shadowPane",\u000a    two_pi: 2 * Math.PI,\u000a    target_fps: 32,\u000a    smoothFactor: 1.0,\u000a    _tThresh: 100000000.0,\u000a    C1: 1000000.0,\u000a    C2: 200.0,\u000a\u000a    options: {\u000a        startPaused: false,\u000a        showPaths: true,\u000a        normal: {\u000a            dotColor: "#000000",\u000a            pathColor: "#000000",\u000a            pathOpacity: 0.5,\u000a            pathWidth: 1\u000a        },\u000a        selected: {\u000a            dotColor: "#FFFFFF",\u000a            dotStrokeColor: "#FFFFFF",\u000a            pathColor: "#000000",\u000a            pathOpacity: 0.7,\u000a            pathWidth: 3\u000a        }\u000a    },\u000a\u000a    // -- initialized is called on prototype\u000a    initialize: function (items, options) {\u000a        this._map = null;\u000a        this._canvas = null;\u000a        this._ctx = null;\u000a        this._frame = null;\u000a        this._items = items || null;\u000a        this._timeOffset = 0;\u000a        this._colorPalette = [];\u000a        L.setOptions(this, options);\u000a        this._paused = this.options.startPaused;\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    _onLayerDidResize: function (resizeEvent) {\u000a        let newWidth = resizeEvent.newSize.x,\u000a            newHeight = resizeEvent.newSize.y;\u000a\u000a        this._canvas.width = newWidth;\u000a        this._canvas.height = newHeight;\u000a\u000a        this._canvas2.width = newWidth;\u000a        this._canvas2.height = newHeight;\u000a\u000a        this._setupWindow();\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    _onLayerDidMove: function () {\u000a        this._mapMoving = false;\u000a\u000a        let topLeft = this._map.containerPointToLayerPoint([0, 0]);\u000a\u000a        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\u000a        L.DomUtil.setPosition(this._canvas, topLeft);\u000a\u000a        this._ctx2.clearRect(0, 0, this._canvas2.width, this._canvas2.height);\u000a        L.DomUtil.setPosition(this._canvas2, topLeft);\u000a\u000a        this._setupWindow();\u000a\u000a        if (!this._paused) {\u000a            this.animate();\u000a        } else {\u000a            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\u000a        }\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    getEvents: function () {\u000a        var events = {\u000a            movestart: function () {\u000a                this._mapMoving = true;\u000a            },\u000a            moveend: this._onLayerDidMove,\u000a            resize: this._onLayerDidResize\u000a        };\u000a\u000a        if (this._map.options.zoomAnimation && L.Browser.any3d) {\u000a            events.zoomanim = this._animateZoom;\u000a        }\u000a\u000a        return events;\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    onAdd: function (map) {\u000a        this._map = map;\u000a\u000a        let size = this._map.getSize(),\u000a            zoomAnimated = this._map.options.zoomAnimation && L.Browser.any3d;\u000a\u000a        // dotlayer canvas\u000a        this._canvas = L.DomUtil.create("canvas", "leaflet-layer");\u000a        this._canvas.width = size.x;\u000a        this._canvas.height = size.y;\u000a        this._ctx = this._canvas.getContext("2d");\u000a        L.DomUtil.addClass(this._canvas, "leaflet-zoom-" + (zoomAnimated ? "animated" : "hide"));\u000a        map._panes.shadowPane.style.pointerEvents = "none";\u000a        map._panes.shadowPane.appendChild(this._canvas);\u000a\u000a        // create Canvas for polyline-ish things\u000a        this._canvas2 = L.DomUtil.create("canvas", "leaflet-layer");\u000a        this._canvas2.width = size.x;\u000a        this._canvas2.height = size.y;\u000a        this._ctx2 = this._canvas2.getContext("2d");\u000a        this._ctx2.lineCap = "round";\u000a        this._ctx2.lineJoin = "round";\u000a        L.DomUtil.addClass(this._canvas2, "leaflet-zoom-" + (zoomAnimated ? "animated" : "hide"));\u000a        map._panes.overlayPane.appendChild(this._canvas2);\u000a\u000a        map.on(this.getEvents(), this);\u000a\u000a        if (this._items) {\u000a\u000a            // Set dotColors for these items\u000a            let itemsList = Object.values(this._items),\u000a                numItems = itemsList.length;\u000a\u000a            this._colorPalette = createPalette(numItems);\u000a            for (let i = 0; i < numItems; i++) {\u000a                itemsList[i].dotColor = this._colorPalette[i];\u000a            }\u000a\u000a            this._onLayerDidMove();\u000a        }\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    onRemove: function (map) {\u000a        this.onLayerWillUnmount && this.onLayerWillUnmount(); // -- callback\u000a\u000a\u000a        // map.getPanes().overlayPane.removeChild(this._canvas);\u000a        map._panes.shadowPane.removeChild(this._canvas);\u000a        this._canvas = null;\u000a\u000a        map._panes.overlayPane.removeChild(this._canvas2);\u000a        this._canvas2 = null;\u000a\u000a        map.off(this.getEvents(), this);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    addTo: function (map) {\u000a        map.addLayer(this);\u000a        return this;\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    LatLonToMercator: function (latlon) {\u000a        return {\u000a            x: latlon.lng * 6378137 * Math.PI / 180,\u000a            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\u000a        };\u000a    },\u000a\u000a    // -------------------------------------------------------------------\u000a    _setupWindow: function () {\u000a        if (!this._map || !this._items) {\u000a            return;\u000a        }\u000a\u000a        const t0 = performance.now();\u000a\u000a        // Get new map orientation\u000a        this._zoom = this._map.getZoom();\u000a        this._center = this._map.getCenter;\u000a        this._size = this._map.getSize();\u000a\u000a        this._latLngBounds = this._map.getBounds();\u000a        this._mapPanePos = this._map._getMapPanePos();\u000a        this._pxOrigin = this._map.getPixelOrigin();\u000a        this._pxBounds = this._map.getPixelBounds();\u000a        this._pxOffset = this._mapPanePos.subtract(this._pxOrigin)._add(new L.Point(0.5, 0.5));\u000a\u000a        var line_ctx = this._ctx2,\u000a            z = this._zoom,\u000a            ppos = this._mapPanePos,\u000a            pxOrigin = this._pxOrigin,\u000a            pxBounds = this._pxBounds,\u000a            items = this._items;\u000a\u000a        this._ctx.strokeStyle = this.options.selected.dotStrokeColor;\u000a\u000a        this._dotSize = Math.log(z);\u000a        this._dotOffset = ~~(this._dotSize / 2 + 0.5);\u000a        this._zoomFactor = 1 / Math.pow(2, z);\u000a\u000a        var tThresh = this._tThresh * DotLayer._zoomFactor;\u000a\u000a        // console.log( `zoom=${z}\u005cnmapPanePos=${ppos}\u005cnsize=${this._size}\u005cn` +\u000a        //             `pxOrigin=${pxOrigin}\u005cnpxBounds=[${pxBounds.min}, ${pxBounds.max}]`\u000a        //              );\u000a\u000a\u000a        this._processedItems = {};\u000a\u000a        let A, cp, contained, projected, c1, c2;\u000a\u000a        for (let id in items) {\u000a            if (!items.hasOwnProperty(id)) {\u000a                //The current property is not a direct property of p\u000a                continue;\u000a            }\u000a\u000a            A = this._items[id];\u000a            drawingLine = false;\u000a\u000a            if (!A.projected) {\u000a                A.projected = {};\u000a            }\u000a\u000a            if ("latlng" in A && this._latLngBounds.overlaps(A.bounds) && "time" in A) {\u000a                projected = A.projected[z];\u000a\u000a                if (!projected) {\u000a                    projected = A.latlng.map((latLng, i) => Object.assign(this._map.project(latLng), { t: A.time[i] }));\u000a\u000a                    projected = L.LineUtil.simplify(projected, this.smoothFactor);\u000a                    A.projected[z] = projected;\u000a                }\u000a\u000a                contained = projected.map(p => this._pxBounds.contains(p));\u000a\u000a                cp = [];\u000a\u000a                for (let p1, p2, i = 1, len = projected.length; i < len; i++) {\u000a                    if (contained[i - 1] || contained[i]) {\u000a                        p1 = projected[i - 1];\u000a                        p2 = projected[i];\u000a\u000a                        // Compute derivative at this point if we haven't yet\u000a                        if (!p1.dx && !p1.dy && !p1.isBad) {\u000a                            dt = p2.t - p1.t;\u000a                            Object.assign(p1, { dx: (p2.x - p1.x) / dt, dy: (p2.y - p1.y) / dt, t2: p2.t });\u000a\u000a                            if (dt > tThresh) {\u000a                                p1.isBad = true;\u000a                                // Console.log(`bad segment ${p1}, ${p2}`);\u000a                            }\u000a                        }\u000a\u000a                        if (!p1.isBad) {\u000a                            cp.push(p1);\u000a\u000a                            if (this.options.showPaths) {\u000a                                if (!drawingLine) {\u000a                                    line_ctx.beginPath();\u000a                                    drawingLine = true;\u000a                                }\u000a                                // draw polyline segment from p1 to p2\u000a                                c1 = p1.add(this._pxOffset);\u000a                                c2 = p2.add(this._pxOffset);\u000a                                line_ctx.moveTo(c1.x, c1.y);\u000a                                line_ctx.lineTo(c2.x, c2.y);\u000a                            }\u000a                        }\u000a                    }\u000a                }\u000a\u000a                if (this.options.showPaths) {\u000a                    if (drawingLine) {\u000a                        lineType = A.highlighted ? "selected" : "normal";\u000a                        line_ctx.globalAlpha = this.options[lineType].pathOpacity;\u000a                        line_ctx.lineWidth = this.options[lineType].pathWidth;\u000a                        line_ctx.strokeStyle = A.path_color || this.options[lineType].pathColor;\u000a                        line_ctx.stroke();\u000a                    } else {\u000a                        line_ctx.stroke();\u000a                    }\u000a                }\u000a\u000a                if (cp.length > 1) {\u000a                    this._processedItems[id] = {\u000a                        cp: cp,\u000a\u000a                        dotColor: A.dotColor,\u000a\u000a                        startTime: new Date(A.ts_UTC || A.beginTimestamp).getTime(),\u000a                        totSec: A.time.slice(-1)[0]\u000a                    };\u000a                }\u000a            }\u000a        }\u000a\u000a        elapsed = (performance.now() - t0).toFixed(2);\u000a        // Console.log(`dot context update took ${elapsed} ms`);\u000a        // console.log(this._processedItems);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    drawDots: function (obj, now, highlighted) {\u000a        var P = obj.cp,\u000a            lenP = P.length,\u000a            totSec = obj.totSec,\u000a            zf = this._zoomFactor,\u000a            dT = this.C1 * zf,\u000a            s = this.C2 * zf * (now - obj.startTime),\u000a            xmax = this._size.x,\u000a            ymax = this._size.y,\u000a            ctx = this._ctx,\u000a            dotSize = this._dotSize,\u000a            dotOffset = this._dotOffset,\u000a            two_pi = this.two_pi,\u000a            xOffset = this._pxOffset.x,\u000a            yOffset = this._pxOffset.y;\u000a\u000a        var timeOffset = s % dT,\u000a            count = 0,\u000a            i = 0,\u000a            t,\u000a            dt,\u000a            p = P[0],\u000a            lx,\u000a            ly;\u000a\u000a        if (highlighted) {\u000a            ctx.fillStyle = obj.dotColor || this.options.selected.dotColor;\u000a        }\u000a\u000a        if (timeOffset < 0) {\u000a            timeOffset += dT;\u000a        }\u000a\u000a        // Console.log("\u005cnnew obj");\u000a        // let out;\u000a\u000a        for (t = timeOffset; t < totSec; t += dT) {\u000a            while (t >= p.t2) {\u000a                i++;\u000a                p = P[i];\u000a                if (i >= lenP) return count;\u000a            }\u000a\u000a            dt = t - p.t;\u000a            if (dt > 0) {\u000a                lx = ~~(p.x + p.dx * dt + xOffset);\u000a                ly = ~~(p.y + p.dy * dt + yOffset);\u000a\u000a                if (lx >= 0 && lx <= xmax && ly >= 0 && ly <= ymax) {\u000a                    if (highlighted) {\u000a                        ctx.beginPath();\u000a                        ctx.arc(lx, ly, dotSize, 0, two_pi);\u000a                        ctx.fill();\u000a                        ctx.closePath();\u000a                        ctx.stroke();\u000a                    } else {\u000a                        ctx.fillRect(lx - dotOffset, ly - dotOffset, dotSize, dotSize);\u000a                    }\u000a                    count++;\u000a                }\u000a            }\u000a        }\u000a        return count;\u000a    },\u000a\u000a    drawLayer: function (now) {\u000a        if (!this._map) {\u000a            return;\u000a        }\u000a\u000a        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\u000a        this._ctx.fillStyle = this.options.normal.dotColor;\u000a\u000a        var ctx = this._ctx,\u000a            zoom = this._zoom,\u000a            count = 0,\u000a            t0 = performance.now(),\u000a            id,\u000a            item,\u000a            items = this._items,\u000a            pItem,\u000a            pItems = this._processedItems,\u000a            highlighted_items = [];\u000a\u000a        for (id in pItems) {\u000a            item = pItems[id];\u000a            if (items[id].highlighted) {\u000a                highlighted_items.push(item);\u000a            } else {\u000a                debugger;\u000a                count += this.drawDots(item, now, false);\u000a            }\u000a        }\u000a\u000a        // Now plot highlighted paths\u000a        var i,\u000a            dotColor,\u000a            hlen = highlighted_items.length;\u000a        if (hlen) {\u000a            for (i = 0; i < hlen; i++) {\u000a                item = highlighted_items[i];\u000a                count += this.drawDots(item, now, true);\u000a            }\u000a        }\u000a\u000a        var elapsed = (performance.now() - t0).toFixed(1);\u000a        fps_display && fps_display.update(now, `${elapsed} ms/f, n=${count}, z=${this._zoom}`);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    animate: function () {\u000a        this._paused = false;\u000a        this.lastCalledTime = 0;\u000a        this.minDelay = ~~(1000 / this.target_fps + 0.5);\u000a        this._frame = L.Util.requestAnimFrame(this._animate, this);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    pause: function () {\u000a        this._paused = true;\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    _animate: function () {\u000a        if (this._paused || this._mapMoving) {\u000a            // Ths is so we can start where we left off when we resume\u000a            this._timePaused = Date.now();\u000a            return;\u000a        }\u000a\u000a        if (this._timePaused) {\u000a            this._timeOffset = Date.now() - this._timePaused;\u000a            this._timePaused = null;\u000a        }\u000a\u000a        let now = Date.now() - this._timeOffset;\u000a        if (now - this.lastCalledTime > this.minDelay) {\u000a            this.lastCalledTime = now;\u000a            this.drawLayer(now);\u000a        }\u000a\u000a        this._frame = null;\u000a\u000a        this._frame = this._frame || L.Util.requestAnimFrame(this._animate, this);\u000a    },\u000a\u000a    // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7\u000a    //------------------------------------------------------------------------------\u000a    _setTransform: function (el, offset, scale) {\u000a        var pos = offset || new L.Point(0, 0);\u000a\u000a        el.style[L.DomUtil.TRANSFORM] = (L.Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");\u000a    },\u000a\u000a    //------------------------------------------------------------------------------\u000a    _animateZoom: function (e) {\u000a        var scale = this._map.getZoomScale(e.zoom);\u000a\u000a        // -- different calc of offset in leaflet 1.0.0 and 0.0.7 thanks for 1.0.0-rc2 calc @jduggan1\u000a        var offset = L.Layer ? this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center) : this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\u000a\u000a        L.DomUtil.setTransform(this._canvas, offset, scale);\u000a    }\u000a});\u000a\u000aL.dotLayer = function (items, options) {\u000a    return new L.DotLayer(items, options);\u000a};\u000a\u000a/* From http://stackoverflow.com/a/20591891/4718949 */\u000afunction hslToRgbString(h, s, l) {\u000a    return "hsl(" + h + "," + s + "%," + l + "% )";\u000a}\u000a\u000afunction createPalette(colorCount) {\u000a    let newPalette = [],\u000a        hueStep = Math.floor(330 / colorCount),\u000a        hue = 0,\u000a        saturation = 95,\u000a        luminosity = 55,\u000a        greenJump = false;\u000a\u000a    for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {\u000a        saturation = colorIndex & 1 ? 90 : 65;\u000a        luminosity = colorIndex & 1 ? 80 : 55;\u000a        newPalette.push(hslToRgbString(hue, saturation, luminosity));\u000a        hue += hueStep;\u000a        if (!greenJump && hue > 100) {\u000a            hue += 30;\u000a            greenJump = true;\u000a        }\u000a    }\u000a    return newPalette;\u000a}\u000a\u000a
p1
.