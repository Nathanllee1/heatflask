V// Based on https://github.com/shramov/leaflet-plugins\u000a// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery\u000a\u000a\u000a// \U0001f342class GridLayer.GoogleMutant\u000a// \U0001f342extends GridLayer\u000aL.GridLayer.GoogleMutant = L.GridLayer.extend({\u000a	includes: L.Mixin.Events,\u000a\u000a	options: {\u000a		minZoom: 0,\u000a		maxZoom: 18,\u000a		tileSize: 256,\u000a		subdomains: 'abc',\u000a		errorTileUrl: '',\u000a		attribution: '', // The mutant container will add its own attribution anyways.\u000a		opacity: 1,\u000a		continuousWorld: false,\u000a		noWrap: false,\u000a		// \U0001f342option type: String = 'roadmap'\u000a		// Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.\u000a		type: 'roadmap',\u000a		maxNativeZoom: 21\u000a	},\u000a\u000a	initialize: function (options) {\u000a		L.GridLayer.prototype.initialize.call(this, options);\u000a\u000a		this._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;\u000a\u000a		this._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {\u000a			var checkCounter = 0;\u000a			var intervalId = null;\u000a			intervalId = setInterval(function () {\u000a				if (checkCounter >= 10) {\u000a					clearInterval(intervalId);\u000a					return reject(new Error('window.google not found after 10 attempts'));\u000a				}\u000a				if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {\u000a					clearInterval(intervalId);\u000a					return resolve(window.google);\u000a				}\u000a				checkCounter++;\u000a			}, 500);\u000a		});\u000a\u000a		// Couple data structures indexed by tile key\u000a		this._tileCallbacks = {}; // Callbacks for promises for tiles that are expected\u000a		this._freshTiles = {}; // Tiles from the mutant which haven't been requested yet\u000a\u000a		this._imagesPerTile = this.options.type === 'hybrid' ? 2 : 1;\u000a	},\u000a\u000a	onAdd: function (map) {\u000a		L.GridLayer.prototype.onAdd.call(this, map);\u000a		this._initMutantContainer();\u000a\u000a		this._GAPIPromise.then(function () {\u000a			this._ready = true;\u000a			this._map = map;\u000a\u000a			this._initMutant();\u000a\u000a			map.on('viewreset', this._reset, this);\u000a			map.on('move', this._update, this);\u000a			map.on('zoomend', this._handleZoomAnim, this);\u000a			map.on('resize', this._resize, this);\u000a\u000a			//handle layer being added to a map for which there are no Google tiles at the given zoom\u000a			google.maps.event.addListenerOnce(this._mutant, 'idle', function () {\u000a				this._checkZoomLevels();\u000a				this._mutantIsReady = true;\u000a			}.bind(this));\u000a\u000a			//20px instead of 1em to avoid a slight overlap with google's attribution\u000a			map._controlCorners.bottomright.style.marginBottom = '20px';\u000a			map._controlCorners.bottomleft.style.marginBottom = '20px';\u000a\u000a			this._reset();\u000a			this._update();\u000a\u000a			if (this._subLayers) {\u000a				//restore previously added google layers\u000a				for (var layerName in this._subLayers) {\u000a					this._subLayers[layerName].setMap(this._mutant);\u000a				}\u000a			}\u000a		}.bind(this));\u000a	},\u000a\u000a	onRemove: function (map) {\u000a		L.GridLayer.prototype.onRemove.call(this, map);\u000a		map._container.removeChild(this._mutantContainer);\u000a		this._mutantContainer = undefined;\u000a\u000a		map.off('viewreset', this._reset, this);\u000a		map.off('move', this._update, this);\u000a		map.off('zoomend', this._handleZoomAnim, this);\u000a		map.off('resize', this._resize, this);\u000a\u000a		map._controlCorners.bottomright.style.marginBottom = '0em';\u000a		map._controlCorners.bottomleft.style.marginBottom = '0em';\u000a	},\u000a\u000a	getAttribution: function () {\u000a		return this.options.attribution;\u000a	},\u000a\u000a	setOpacity: function (opacity) {\u000a		this.options.opacity = opacity;\u000a		if (opacity < 1) {\u000a			L.DomUtil.setOpacity(this._mutantContainer, opacity);\u000a		}\u000a	},\u000a\u000a	setElementSize: function (e, size) {\u000a		e.style.width = size.x + 'px';\u000a		e.style.height = size.y + 'px';\u000a	},\u000a\u000a	addGoogleLayer: function (googleLayerName, options) {\u000a		if (!this._subLayers) this._subLayers = {};\u000a		return this._GAPIPromise.then(function () {\u000a			var Constructor = google.maps[googleLayerName];\u000a			var googleLayer = new Constructor(options);\u000a			googleLayer.setMap(this._mutant);\u000a			this._subLayers[googleLayerName] = googleLayer;\u000a			return googleLayer;\u000a		}.bind(this));\u000a	},\u000a\u000a	removeGoogleLayer: function (googleLayerName) {\u000a		var googleLayer = this._subLayers && this._subLayers[googleLayerName];\u000a		if (!googleLayer) return;\u000a\u000a		googleLayer.setMap(null);\u000a		delete this._subLayers[googleLayerName];\u000a	},\u000a\u000a	_initMutantContainer: function () {\u000a		if (!this._mutantContainer) {\u000a			this._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');\u000a			this._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);\u000a			this._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000\u000a			this._mutantContainer.style.pointerEvents = 'none';\u000a\u000a			this._map.getContainer().appendChild(this._mutantContainer);\u000a		}\u000a\u000a		this.setOpacity(this.options.opacity);\u000a		this.setElementSize(this._mutantContainer, this._map.getSize());\u000a\u000a		this._attachObserver(this._mutantContainer);\u000a	},\u000a\u000a	_initMutant: function () {\u000a		if (!this._ready || !this._mutantContainer) return;\u000a		this._mutantCenter = new google.maps.LatLng(0, 0);\u000a\u000a		var map = new google.maps.Map(this._mutantContainer, {\u000a			center: this._mutantCenter,\u000a			zoom: 0,\u000a			tilt: 0,\u000a			mapTypeId: this.options.type,\u000a			disableDefaultUI: true,\u000a			keyboardShortcuts: false,\u000a			draggable: false,\u000a			disableDoubleClickZoom: true,\u000a			scrollwheel: false,\u000a			streetViewControl: false,\u000a			styles: this.options.styles || {},\u000a			backgroundColor: 'transparent'\u000a		});\u000a\u000a		this._mutant = map;\u000a\u000a		google.maps.event.addListenerOnce(map, 'idle', function () {\u000a			var nodes = this._mutantContainer.querySelectorAll('a');\u000a			for (var i = 0; i < nodes.length; i++) {\u000a				nodes[i].style.pointerEvents = 'auto';\u000a			}\u000a		}.bind(this));\u000a\u000a		// \U0001f342event spawned\u000a		// Fired when the mutant has been created.\u000a		this.fire('spawned', { mapObject: map });\u000a	},\u000a\u000a	_attachObserver: function _attachObserver(node) {\u000a		// 		console.log('Gonna observe', node);\u000a\u000a		var observer = new MutationObserver(this._onMutations.bind(this));\u000a\u000a		// pass in the target node, as well as the observer options\u000a		observer.observe(node, { childList: true, subtree: true });\u000a	},\u000a\u000a	_onMutations: function _onMutations(mutations) {\u000a		for (var i = 0; i < mutations.length; ++i) {\u000a			var mutation = mutations[i];\u000a			for (var j = 0; j < mutation.addedNodes.length; ++j) {\u000a				var node = mutation.addedNodes[j];\u000a\u000a				if (node instanceof HTMLImageElement) {\u000a					this._onMutatedImage(node);\u000a				} else if (node instanceof HTMLElement) {\u000a					Array.prototype.forEach.call(node.querySelectorAll('img'), this._onMutatedImage.bind(this));\u000a				}\u000a			}\u000a		}\u000a	},\u000a\u000a	// Only images which 'src' attrib match this will be considered for moving around.\u000a	// Looks like some kind of string-based protobuf, maybe??\u000a	// Only the roads (and terrain, and vector-based stuff) match this pattern\u000a	_roadRegexp: /!1i(\u005cd+)!2i(\u005cd+)!3i(\u005cd+)!/,\u000a\u000a	// On the other hand, raster imagery matches this other pattern\u000a	_satRegexp: /x=(\u005cd+)&y=(\u005cd+)&z=(\u005cd+)/,\u000a\u000a	// On small viewports, when zooming in/out, a static image is requested\u000a	// This will not be moved around, just removed from the DOM.\u000a	_staticRegExp: /StaticMapService\u005c.GetMapImage/,\u000a\u000a	_onMutatedImage: function _onMutatedImage(imgNode) {\u000a		// 		if (imgNode.src) {\u000a		// 			console.log('caught mutated image: ', imgNode.src);\u000a		// 		}\u000a\u000a		var coords;\u000a		var match = imgNode.src.match(this._roadRegexp);\u000a		var sublayer = 0;\u000a\u000a		if (match) {\u000a			coords = {\u000a				z: match[1],\u000a				x: match[2],\u000a				y: match[3]\u000a			};\u000a			if (this._imagesPerTile > 1) {\u000a				imgNode.style.zIndex = 1;\u000a				sublayer = 1;\u000a			}\u000a		} else {\u000a			match = imgNode.src.match(this._satRegexp);\u000a			if (match) {\u000a				coords = {\u000a					x: match[1],\u000a					y: match[2],\u000a					z: match[3]\u000a				};\u000a			}\u000a			// 			imgNode.style.zIndex = 0;\u000a			sublayer = 0;\u000a		}\u000a\u000a		if (coords) {\u000a			var tileKey = this._tileCoordsToKey(coords);\u000a			imgNode.style.position = 'absolute';\u000a			var cloneImgNode = imgNode.cloneNode(true);\u000a			cloneImgNode.style.visibility = 'visible';\u000a			imgNode.style.visibility = 'hidden';\u000a\u000a			var key = tileKey + '/' + sublayer;\u000a			if (key in this._tileCallbacks && this._tileCallbacks[key]) {\u000a				// console.log('Fullfilling callback ', key);\u000a				this._tileCallbacks[key].shift()(cloneImgNode);\u000a				if (!this._tileCallbacks[key].length) {\u000a					delete this._tileCallbacks[key];\u000a				}\u000a			} else {\u000a				// console.log('Caching for later', key);\u000a\u000a				if (this._tiles[tileKey]) {\u000a					//we already have a tile in this position (mutation is probably a google layer being added)\u000a					//replace it\u000a					var c = this._tiles[tileKey].el;\u000a					var oldImg = sublayer === 0 ? c.firstChild : c.firstChild.nextSibling;\u000a					c.replaceChild(cloneImgNode, oldImg);\u000a				} else if (key in this._freshTiles) {\u000a					this._freshTiles[key].push(cloneImgNode);\u000a				} else {\u000a					this._freshTiles[key] = [cloneImgNode];\u000a				}\u000a			}\u000a		} else if (imgNode.src.match(this._staticRegExp)) {\u000a			imgNode.style.visibility = 'hidden';\u000a		}\u000a	},\u000a\u000a	createTile: function (coords, done) {\u000a		var key = this._tileCoordsToKey(coords);\u000a\u000a		var tileContainer = L.DomUtil.create('div');\u000a		tileContainer.dataset.pending = this._imagesPerTile;\u000a		done = done.bind(this, null, tileContainer);\u000a\u000a		for (var i = 0; i < this._imagesPerTile; i++) {\u000a			var key2 = key + '/' + i;\u000a			if (key2 in this._freshTiles) {\u000a				tileContainer.appendChild(this._freshTiles[key2].pop());\u000a				if (!this._freshTiles[key2].length) {\u000a					delete this._freshTiles[key2];\u000a				}\u000a				tileContainer.dataset.pending--;\u000a				// 				console.log('Got ', key2, ' from _freshTiles');\u000a			} else {\u000a				this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];\u000a				this._tileCallbacks[key2].push(function (c /*, k2*/) {\u000a					return function (cloneImgNode) {\u000a						c.appendChild(cloneImgNode);\u000a						c.dataset.pending--;\u000a						if (!parseInt(c.dataset.pending)) {\u000a							done();\u000a						}\u000a						// 						console.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');\u000a					}.bind(this);\u000a				}.bind(this)(tileContainer /*, key2*/));\u000a			}\u000a		}\u000a\u000a		if (!parseInt(tileContainer.dataset.pending)) {\u000a			L.Util.requestAnimFrame(done);\u000a		}\u000a		return tileContainer;\u000a	},\u000a\u000a	_checkZoomLevels: function () {\u000a		//setting the zoom level on the Google map may result in a different zoom level than the one requested\u000a		//(it won't go beyond the level for which they have data).\u000a		var zoomLevel = this._map.getZoom();\u000a		var gMapZoomLevel = this._mutant.getZoom();\u000a		if (!zoomLevel || !gMapZoomLevel) return;\u000a\u000a		if (gMapZoomLevel !== zoomLevel || //zoom levels are out of sync, Google doesn't have data\u000a		gMapZoomLevel > this.options.maxNativeZoom) {\u000a			//at current location, Google does have data (contrary to maxNativeZoom)\u000a			//Update maxNativeZoom\u000a			this._setMaxNativeZoom(gMapZoomLevel);\u000a		}\u000a	},\u000a\u000a	_setMaxNativeZoom: function (zoomLevel) {\u000a		if (zoomLevel != this.options.maxNativeZoom) {\u000a			this.options.maxNativeZoom = zoomLevel;\u000a			this._resetView();\u000a		}\u000a	},\u000a\u000a	_reset: function () {\u000a		this._initContainer();\u000a	},\u000a\u000a	_update: function () {\u000a		// zoom level check needs to happen before super's implementation (tile addition/creation)\u000a		// otherwise tiles may be missed if maxNativeZoom is not yet correctly determined\u000a		if (this._mutant) {\u000a			var center = this._map.getCenter();\u000a			var _center = new google.maps.LatLng(center.lat, center.lng);\u000a\u000a			this._mutant.setCenter(_center);\u000a			var zoom = this._map.getZoom();\u000a			var fractionalLevel = zoom !== Math.round(zoom);\u000a			var mutantZoom = this._mutant.getZoom();\u000a\u000a			//ignore fractional zoom levels\u000a			if (!fractionalLevel && zoom != mutantZoom) {\u000a				this._mutant.setZoom(zoom);\u000a\u000a				if (this._mutantIsReady) this._checkZoomLevels();\u000a				//else zoom level check will be done later by 'idle' handler\u000a			}\u000a		}\u000a\u000a		L.GridLayer.prototype._update.call(this);\u000a	},\u000a\u000a	_resize: function () {\u000a		var size = this._map.getSize();\u000a		if (this._mutantContainer.style.width === size.x && this._mutantContainer.style.height === size.y) return;\u000a		this.setElementSize(this._mutantContainer, size);\u000a		if (!this._mutant) return;\u000a		google.maps.event.trigger(this._mutant, 'resize');\u000a	},\u000a\u000a	_handleZoomAnim: function () {\u000a		if (!this._mutant) return;\u000a		var center = this._map.getCenter();\u000a		var _center = new google.maps.LatLng(center.lat, center.lng);\u000a\u000a		this._mutant.setCenter(_center);\u000a		this._mutant.setZoom(Math.round(this._map.getZoom()));\u000a	},\u000a\u000a	// Agressively prune _freshtiles when a tile with the same key is removed,\u000a	// this prevents a problem where Leaflet keeps a loaded tile longer than\u000a	// GMaps, so that GMaps makes two requests but Leaflet only consumes one,\u000a	// polluting _freshTiles with stale data.\u000a	_removeTile: function (key) {\u000a		if (!this._mutant) return;\u000a\u000a		for (var i = 0; i < this._imagesPerTile; i++) {\u000a			var key2 = key + '/' + i;\u000a			if (key2 in this._freshTiles) {\u000a				delete this._freshTiles[key2];\u000a			}\u000a			// 				console.log('Pruned spurious hybrid _freshTiles');\u000a		}\u000a\u000a		//if the tile is still visible in the google map, keep it.\u000a		//In this situation, if the tile is later required, there won't be a mutation event (since tile is already in gMap) \u000a		//and there will be no other way to refetch the tile.\u000a		//this situation where GMaps keeps a tile longer than Leaflet can happen when the map goes past \u000a		//self's maxNativeZoom\u000a		var gZoom = this._mutant.getZoom();\u000a		var zoom = key.split(':')[2];\u000a		if (zoom == gZoom && gZoom == this.options.maxNativeZoom) {\u000a			var imgs = this._tiles[key].el.querySelectorAll('img');\u000a			if (imgs.length) {\u000a				for (var j = 0; j < this._imagesPerTile; j++) {\u000a					var keyJ = key + '/' + j;\u000a					var imgNode = imgs[j];\u000a					if (keyJ in this._freshTiles) {\u000a						this._freshTiles[keyJ].push(imgNode);\u000a					} else {\u000a						this._freshTiles[keyJ] = [imgNode];\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return L.GridLayer.prototype._removeTile.call(this, key);\u000a	}\u000a});\u000a\u000a// \U0001f342factory gridLayer.googleMutant(options)\u000a// Returns a new `GridLayer.GoogleMutant` given its options\u000aL.gridLayer.googleMutant = function (options) {\u000a	return new L.GridLayer.GoogleMutant(options);\u000a};\u000a\u000a
p1
.