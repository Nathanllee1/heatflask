V(function (f) {\u000a    if (typeof exports === "object" && typeof module !== "undefined") {\u000a        module.exports = f();\u000a    } else if (typeof define === "function" && define.amd) {\u000a        define([], f);\u000a    } else {\u000a        var g;if (typeof window !== "undefined") {\u000a            g = window;\u000a        } else if (typeof global !== "undefined") {\u000a            g = global;\u000a        } else if (typeof self !== "undefined") {\u000a            g = self;\u000a        } else {\u000a            g = this;\u000a        }g.leafletImage = f();\u000a    }\u000a})(function () {\u000a    var define, module, exports;return function e(t, n, r) {\u000a        function s(o, u) {\u000a            if (!n[o]) {\u000a                if (!t[o]) {\u000a                    var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;\u000a                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\u000a                    var n = t[o][1][e];return s(n ? n : e);\u000a                }, l, l.exports, e, t, n, r);\u000a            }return n[o].exports;\u000a        }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;\u000a    }({ 1: [function (require, module, exports) {\u000a            /* global L */\u000a\u000a            var queue = require('d3-queue').queue;\u000a\u000a            var cacheBusterDate = +new Date();\u000a\u000a            // leaflet-image\u000a            module.exports = function leafletImage(map, callback) {\u000a\u000a                var hasMapbox = !!L.mapbox;\u000a\u000a                var dimensions = map.getSize(),\u000a                    layerQueue = new queue(1);\u000a\u000a                var canvas = document.createElement('canvas');\u000a                canvas.width = dimensions.x;\u000a                canvas.height = dimensions.y;\u000a                var ctx = canvas.getContext('2d');\u000a\u000a                // dummy canvas image when loadTile get 404 error\u000a                // and layer don't have errorTileUrl\u000a                var dummycanvas = document.createElement('canvas');\u000a                dummycanvas.width = 1;\u000a                dummycanvas.height = 1;\u000a                var dummyctx = dummycanvas.getContext('2d');\u000a                dummyctx.fillStyle = 'rgba(0,0,0,0)';\u000a                dummyctx.fillRect(0, 0, 1, 1);\u000a\u000a                // layers are drawn in the same order as they are composed in the DOM:\u000a                // tiles, paths, and then markers\u000a                map.eachLayer(drawTileLayer);\u000a                map.eachLayer(drawEsriDynamicLayer);\u000a\u000a                if (map._pathRoot) {\u000a                    layerQueue.defer(handlePathRoot, map._pathRoot);\u000a                } else if (map._panes) {\u000a                    var firstCanvas = map._panes.overlayPane.getElementsByTagName('canvas').item(0);\u000a                    if (firstCanvas) {\u000a                        layerQueue.defer(handlePathRoot, firstCanvas);\u000a                    }\u000a                }\u000a                map.eachLayer(drawMarkerLayer);\u000a                layerQueue.awaitAll(layersDone);\u000a\u000a                function drawTileLayer(l) {\u000a                    if (l instanceof L.TileLayer) layerQueue.defer(handleTileLayer, l);else if (l._heat) layerQueue.defer(handlePathRoot, l._canvas);\u000a                }\u000a\u000a                function drawMarkerLayer(l) {\u000a                    if (l instanceof L.Marker && l.options.icon instanceof L.Icon) {\u000a                        layerQueue.defer(handleMarkerLayer, l);\u000a                    }\u000a                }\u000a\u000a                function drawEsriDynamicLayer(l) {\u000a                    if (!L.esri) return;\u000a\u000a                    if (l instanceof L.esri.DynamicMapLayer) {\u000a                        layerQueue.defer(handleEsriDymamicLayer, l);\u000a                    }\u000a                }\u000a\u000a                function done() {\u000a                    callback(null, canvas);\u000a                }\u000a\u000a                function layersDone(err, layers) {\u000a                    if (err) throw err;\u000a                    layers.forEach(function (layer) {\u000a                        if (layer && layer.canvas) {\u000a                            ctx.drawImage(layer.canvas, 0, 0);\u000a                        }\u000a                    });\u000a                    done();\u000a                }\u000a\u000a                function handleTileLayer(layer, callback) {\u000a                    // `L.TileLayer.Canvas` was removed in leaflet 1.0\u000a                    var isCanvasLayer = L.TileLayer.Canvas && layer instanceof L.TileLayer.Canvas,\u000a                        canvas = document.createElement('canvas');\u000a\u000a                    canvas.width = dimensions.x;\u000a                    canvas.height = dimensions.y;\u000a\u000a                    var ctx = canvas.getContext('2d'),\u000a                        bounds = map.getPixelBounds(),\u000a                        zoom = map.getZoom(),\u000a                        tileSize = layer.options.tileSize;\u000a\u000a                    if (zoom > layer.options.maxZoom || zoom < layer.options.minZoom ||\u000a                    // mapbox.tileLayer\u000a                    hasMapbox && layer instanceof L.mapbox.tileLayer && !layer.options.tiles) {\u000a                        return callback();\u000a                    }\u000a\u000a                    var tileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor()),\u000a                        tiles = [],\u000a                        j,\u000a                        i,\u000a                        tileQueue = new queue(1);\u000a\u000a                    for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {\u000a                        for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {\u000a                            tiles.push(new L.Point(i, j));\u000a                        }\u000a                    }\u000a\u000a                    tiles.forEach(function (tilePoint) {\u000a                        var originalTilePoint = tilePoint.clone();\u000a\u000a                        if (layer._adjustTilePoint) {\u000a                            layer._adjustTilePoint(tilePoint);\u000a                        }\u000a\u000a                        var tilePos = originalTilePoint.scaleBy(new L.Point(tileSize, tileSize)).subtract(bounds.min);\u000a\u000a                        if (tilePoint.y >= 0) {\u000a                            if (isCanvasLayer) {\u000a                                var tile = layer._tiles[tilePoint.x + ':' + tilePoint.y];\u000a                                tileQueue.defer(canvasTile, tile, tilePos, tileSize);\u000a                            } else {\u000a                                var url = addCacheString(layer.getTileUrl(tilePoint));\u000a                                tileQueue.defer(loadTile, url, tilePos, tileSize);\u000a                            }\u000a                        }\u000a                    });\u000a\u000a                    tileQueue.awaitAll(tileQueueFinish);\u000a\u000a                    function canvasTile(tile, tilePos, tileSize, callback) {\u000a                        callback(null, {\u000a                            img: tile,\u000a                            pos: tilePos,\u000a                            size: tileSize\u000a                        });\u000a                    }\u000a\u000a                    function loadTile(url, tilePos, tileSize, callback) {\u000a                        var im = new Image();\u000a                        im.crossOrigin = '';\u000a                        im.onload = function () {\u000a                            callback(null, {\u000a                                img: this,\u000a                                pos: tilePos,\u000a                                size: tileSize\u000a                            });\u000a                        };\u000a                        im.onerror = function (e) {\u000a                            // use canvas instead of errorTileUrl if errorTileUrl get 404\u000a                            if (layer.options.errorTileUrl != '' && e.target.errorCheck === undefined) {\u000a                                e.target.errorCheck = true;\u000a                                e.target.src = layer.options.errorTileUrl;\u000a                            } else {\u000a                                callback(null, {\u000a                                    img: dummycanvas,\u000a                                    pos: tilePos,\u000a                                    size: tileSize\u000a                                });\u000a                            }\u000a                        };\u000a                        im.src = url;\u000a                    }\u000a\u000a                    function tileQueueFinish(err, data) {\u000a                        data.forEach(drawTile);\u000a                        callback(null, { canvas: canvas });\u000a                    }\u000a\u000a                    function drawTile(d) {\u000a                        ctx.drawImage(d.img, Math.floor(d.pos.x), Math.floor(d.pos.y), d.size, d.size);\u000a                    }\u000a                }\u000a\u000a                function handlePathRoot(root, callback) {\u000a                    var bounds = map.getPixelBounds(),\u000a                        origin = map.getPixelOrigin(),\u000a                        canvas = document.createElement('canvas');\u000a                    canvas.width = dimensions.x;\u000a                    canvas.height = dimensions.y;\u000a                    var ctx = canvas.getContext('2d');\u000a                    var pos = L.DomUtil.getPosition(root).subtract(bounds.min).add(origin);\u000a                    try {\u000a                        ctx.drawImage(root, pos.x, pos.y, canvas.width - pos.x * 2, canvas.height - pos.y * 2);\u000a                        callback(null, {\u000a                            canvas: canvas\u000a                        });\u000a                    } catch (e) {\u000a                        console.error('Element could not be drawn on canvas', root); // eslint-disable-line no-console\u000a                    }\u000a                }\u000a\u000a                function handleMarkerLayer(marker, callback) {\u000a                    var canvas = document.createElement('canvas'),\u000a                        ctx = canvas.getContext('2d'),\u000a                        pixelBounds = map.getPixelBounds(),\u000a                        minPoint = new L.Point(pixelBounds.min.x, pixelBounds.min.y),\u000a                        pixelPoint = map.project(marker.getLatLng()),\u000a                        isBase64 = /^data\u005c:/.test(marker._icon.src),\u000a                        url = isBase64 ? marker._icon.src : addCacheString(marker._icon.src),\u000a                        im = new Image(),\u000a                        options = marker.options.icon.options,\u000a                        size = options.iconSize,\u000a                        pos = pixelPoint.subtract(minPoint),\u000a                        anchor = L.point(options.iconAnchor || size && size.divideBy(2, true));\u000a\u000a                    if (size instanceof L.Point) size = [size.x, size.y];\u000a\u000a                    var x = Math.round(pos.x - size[0] + anchor.x),\u000a                        y = Math.round(pos.y - anchor.y);\u000a\u000a                    canvas.width = dimensions.x;\u000a                    canvas.height = dimensions.y;\u000a                    im.crossOrigin = '';\u000a\u000a                    im.onload = function () {\u000a                        ctx.drawImage(this, x, y, size[0], size[1]);\u000a                        callback(null, {\u000a                            canvas: canvas\u000a                        });\u000a                    };\u000a\u000a                    im.src = url;\u000a\u000a                    if (isBase64) im.onload();\u000a                }\u000a\u000a                function handleEsriDymamicLayer(dynamicLayer, callback) {\u000a                    var canvas = document.createElement('canvas');\u000a                    canvas.width = dimensions.x;\u000a                    canvas.height = dimensions.y;\u000a\u000a                    var ctx = canvas.getContext('2d');\u000a\u000a                    var im = new Image();\u000a                    im.crossOrigin = '';\u000a                    im.src = addCacheString(dynamicLayer._currentImage._image.src);\u000a\u000a                    im.onload = function () {\u000a                        ctx.drawImage(im, 0, 0);\u000a                        callback(null, {\u000a                            canvas: canvas\u000a                        });\u000a                    };\u000a                }\u000a\u000a                function addCacheString(url) {\u000a                    // If it's a data URL we don't want to touch this.\u000a                    if (isDataURL(url) || url.indexOf('mapbox.com/styles/v1') !== -1) {\u000a                        return url;\u000a                    }\u000a                    return url + (url.match(/\u005c?/) ? '&' : '?') + 'cache=' + cacheBusterDate;\u000a                }\u000a\u000a                function isDataURL(url) {\u000a                    var dataURLRegex = /^\u005cs*data:([a-z]+\u005c/[a-z]+(;[a-z\u005c-]+\u005c=[a-z\u005c-]+)?)?(;base64)?,[a-z0-9\u005c!\u005c$\u005c&\u005c'\u005c,\u005c(\u005c)\u005c*\u005c+\u005c,\u005c;\u005c=\u005c-\u005c.\u005c_\u005c~\u005c:\u005c@\u005c/\u005c?\u005c%\u005cs]*\u005cs*$/i;\u000a                    return !!url.match(dataURLRegex);\u000a                }\u000a            };\u000a        }, { "d3-queue": 2 }], 2: [function (require, module, exports) {\u000a            (function (global, factory) {\u000a                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.d3_queue = global.d3_queue || {});\u000a            })(this, function (exports) {\u000a                'use strict';\u000a\u000a                var version = "2.0.3";\u000a\u000a                var slice = [].slice;\u000a\u000a                var noabort = {};\u000a\u000a                function Queue(size) {\u000a                    if (!(size >= 1)) throw new Error();\u000a                    this._size = size;\u000a                    this._call = this._error = null;\u000a                    this._tasks = [];\u000a                    this._data = [];\u000a                    this._waiting = this._active = this._ended = this._start = 0; // inside a synchronous task callback?\u000a                }\u000a\u000a                Queue.prototype = queue.prototype = {\u000a                    constructor: Queue,\u000a                    defer: function (callback) {\u000a                        if (typeof callback !== "function" || this._call) throw new Error();\u000a                        if (this._error != null) return this;\u000a                        var t = slice.call(arguments, 1);\u000a                        t.push(callback);\u000a                        ++this._waiting, this._tasks.push(t);\u000a                        poke(this);\u000a                        return this;\u000a                    },\u000a                    abort: function () {\u000a                        if (this._error == null) abort(this, new Error("abort"));\u000a                        return this;\u000a                    },\u000a                    await: function (callback) {\u000a                        if (typeof callback !== "function" || this._call) throw new Error();\u000a                        this._call = function (error, results) {\u000a                            callback.apply(null, [error].concat(results));\u000a                        };\u000a                        maybeNotify(this);\u000a                        return this;\u000a                    },\u000a                    awaitAll: function (callback) {\u000a                        if (typeof callback !== "function" || this._call) throw new Error();\u000a                        this._call = callback;\u000a                        maybeNotify(this);\u000a                        return this;\u000a                    }\u000a                };\u000a\u000a                function poke(q) {\u000a                    if (!q._start) try {\u000a                        start(q);\u000a                    } // let the current task complete\u000a                    catch (e) {\u000a                        if (q._tasks[q._ended + q._active - 1]) abort(q, e);\u000a                    } // task errored synchronously\u000a                }\u000a\u000a                function start(q) {\u000a                    while (q._start = q._waiting && q._active < q._size) {\u000a                        var i = q._ended + q._active,\u000a                            t = q._tasks[i],\u000a                            j = t.length - 1,\u000a                            c = t[j];\u000a                        t[j] = end(q, i);\u000a                        --q._waiting, ++q._active;\u000a                        t = c.apply(null, t);\u000a                        if (!q._tasks[i]) continue; // task finished synchronously\u000a                        q._tasks[i] = t || noabort;\u000a                    }\u000a                }\u000a\u000a                function end(q, i) {\u000a                    return function (e, r) {\u000a                        if (!q._tasks[i]) return; // ignore multiple callbacks\u000a                        --q._active, ++q._ended;\u000a                        q._tasks[i] = null;\u000a                        if (q._error != null) return; // ignore secondary errors\u000a                        if (e != null) {\u000a                            abort(q, e);\u000a                        } else {\u000a                            q._data[i] = r;\u000a                            if (q._waiting) poke(q);else maybeNotify(q);\u000a                        }\u000a                    };\u000a                }\u000a\u000a                function abort(q, e) {\u000a                    var i = q._tasks.length,\u000a                        t;\u000a                    q._error = e; // ignore active callbacks\u000a                    q._data = undefined; // allow gc\u000a                    q._waiting = NaN; // prevent starting\u000a\u000a                    while (--i >= 0) {\u000a                        if (t = q._tasks[i]) {\u000a                            q._tasks[i] = null;\u000a                            if (t.abort) try {\u000a                                t.abort();\u000a                            } catch (e) {/* ignore */}\u000a                        }\u000a                    }\u000a\u000a                    q._active = NaN; // allow notification\u000a                    maybeNotify(q);\u000a                }\u000a\u000a                function maybeNotify(q) {\u000a                    if (!q._active && q._call) q._call(q._error, q._data);\u000a                }\u000a\u000a                function queue(concurrency) {\u000a                    return new Queue(arguments.length ? +concurrency : Infinity);\u000a                }\u000a\u000a                exports.version = version;\u000a                exports.queue = queue;\u000a            });\u000a        }, {}] }, {}, [1])(1);\u000a});\u000a\u000a
p1
.