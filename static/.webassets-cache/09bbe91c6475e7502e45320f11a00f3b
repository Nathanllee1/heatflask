V//! moment.js\u000a//! version : 2.14.1\u000a//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\u000a//! license : MIT\u000a//! momentjs.com\u000a\u000a;(function (global, factory) {\u000a    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();\u000a})(this, function () {\u000a    'use strict';\u000a\u000a    var hookCallback;\u000a\u000a    function utils_hooks__hooks() {\u000a        return hookCallback.apply(null, arguments);\u000a    }\u000a\u000a    // This is done to register the method called with moment()\u000a    // without creating circular dependencies.\u000a    function setHookCallback(callback) {\u000a        hookCallback = callback;\u000a    }\u000a\u000a    function isArray(input) {\u000a        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\u000a    }\u000a\u000a    function isObject(input) {\u000a        return Object.prototype.toString.call(input) === '[object Object]';\u000a    }\u000a\u000a    function isObjectEmpty(obj) {\u000a        var k;\u000a        for (k in obj) {\u000a            // even if its not own property I'd still call it non-empty\u000a            return false;\u000a        }\u000a        return true;\u000a    }\u000a\u000a    function isDate(input) {\u000a        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\u000a    }\u000a\u000a    function map(arr, fn) {\u000a        var res = [],\u000a            i;\u000a        for (i = 0; i < arr.length; ++i) {\u000a            res.push(fn(arr[i], i));\u000a        }\u000a        return res;\u000a    }\u000a\u000a    function hasOwnProp(a, b) {\u000a        return Object.prototype.hasOwnProperty.call(a, b);\u000a    }\u000a\u000a    function extend(a, b) {\u000a        for (var i in b) {\u000a            if (hasOwnProp(b, i)) {\u000a                a[i] = b[i];\u000a            }\u000a        }\u000a\u000a        if (hasOwnProp(b, 'toString')) {\u000a            a.toString = b.toString;\u000a        }\u000a\u000a        if (hasOwnProp(b, 'valueOf')) {\u000a            a.valueOf = b.valueOf;\u000a        }\u000a\u000a        return a;\u000a    }\u000a\u000a    function create_utc__createUTC(input, format, locale, strict) {\u000a        return createLocalOrUTC(input, format, locale, strict, true).utc();\u000a    }\u000a\u000a    function defaultParsingFlags() {\u000a        // We need to deep clone this object.\u000a        return {\u000a            empty: false,\u000a            unusedTokens: [],\u000a            unusedInput: [],\u000a            overflow: -2,\u000a            charsLeftOver: 0,\u000a            nullInput: false,\u000a            invalidMonth: null,\u000a            invalidFormat: false,\u000a            userInvalidated: false,\u000a            iso: false,\u000a            parsedDateParts: [],\u000a            meridiem: null\u000a        };\u000a    }\u000a\u000a    function getParsingFlags(m) {\u000a        if (m._pf == null) {\u000a            m._pf = defaultParsingFlags();\u000a        }\u000a        return m._pf;\u000a    }\u000a\u000a    var some;\u000a    if (Array.prototype.some) {\u000a        some = Array.prototype.some;\u000a    } else {\u000a        some = function (fun) {\u000a            var t = Object(this);\u000a            var len = t.length >>> 0;\u000a\u000a            for (var i = 0; i < len; i++) {\u000a                if (i in t && fun.call(this, t[i], i, t)) {\u000a                    return true;\u000a                }\u000a            }\u000a\u000a            return false;\u000a        };\u000a    }\u000a\u000a    function valid__isValid(m) {\u000a        if (m._isValid == null) {\u000a            var flags = getParsingFlags(m);\u000a            var parsedParts = some.call(flags.parsedDateParts, function (i) {\u000a                return i != null;\u000a            });\u000a            m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\u000a\u000a            if (m._strict) {\u000a                m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\u000a            }\u000a        }\u000a        return m._isValid;\u000a    }\u000a\u000a    function valid__createInvalid(flags) {\u000a        var m = create_utc__createUTC(NaN);\u000a        if (flags != null) {\u000a            extend(getParsingFlags(m), flags);\u000a        } else {\u000a            getParsingFlags(m).userInvalidated = true;\u000a        }\u000a\u000a        return m;\u000a    }\u000a\u000a    function isUndefined(input) {\u000a        return input === void 0;\u000a    }\u000a\u000a    // Plugins that add properties should also add the key here (null value),\u000a    // so we can properly clone ourselves.\u000a    var momentProperties = utils_hooks__hooks.momentProperties = [];\u000a\u000a    function copyConfig(to, from) {\u000a        var i, prop, val;\u000a\u000a        if (!isUndefined(from._isAMomentObject)) {\u000a            to._isAMomentObject = from._isAMomentObject;\u000a        }\u000a        if (!isUndefined(from._i)) {\u000a            to._i = from._i;\u000a        }\u000a        if (!isUndefined(from._f)) {\u000a            to._f = from._f;\u000a        }\u000a        if (!isUndefined(from._l)) {\u000a            to._l = from._l;\u000a        }\u000a        if (!isUndefined(from._strict)) {\u000a            to._strict = from._strict;\u000a        }\u000a        if (!isUndefined(from._tzm)) {\u000a            to._tzm = from._tzm;\u000a        }\u000a        if (!isUndefined(from._isUTC)) {\u000a            to._isUTC = from._isUTC;\u000a        }\u000a        if (!isUndefined(from._offset)) {\u000a            to._offset = from._offset;\u000a        }\u000a        if (!isUndefined(from._pf)) {\u000a            to._pf = getParsingFlags(from);\u000a        }\u000a        if (!isUndefined(from._locale)) {\u000a            to._locale = from._locale;\u000a        }\u000a\u000a        if (momentProperties.length > 0) {\u000a            for (i in momentProperties) {\u000a                prop = momentProperties[i];\u000a                val = from[prop];\u000a                if (!isUndefined(val)) {\u000a                    to[prop] = val;\u000a                }\u000a            }\u000a        }\u000a\u000a        return to;\u000a    }\u000a\u000a    var updateInProgress = false;\u000a\u000a    // Moment prototype object\u000a    function Moment(config) {\u000a        copyConfig(this, config);\u000a        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\u000a        // Prevent infinite loop in case updateOffset creates new moment\u000a        // objects.\u000a        if (updateInProgress === false) {\u000a            updateInProgress = true;\u000a            utils_hooks__hooks.updateOffset(this);\u000a            updateInProgress = false;\u000a        }\u000a    }\u000a\u000a    function isMoment(obj) {\u000a        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\u000a    }\u000a\u000a    function absFloor(number) {\u000a        if (number < 0) {\u000a            // -0 -> 0\u000a            return Math.ceil(number) || 0;\u000a        } else {\u000a            return Math.floor(number);\u000a        }\u000a    }\u000a\u000a    function toInt(argumentForCoercion) {\u000a        var coercedNumber = +argumentForCoercion,\u000a            value = 0;\u000a\u000a        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\u000a            value = absFloor(coercedNumber);\u000a        }\u000a\u000a        return value;\u000a    }\u000a\u000a    // compare two arrays, return the number of differences\u000a    function compareArrays(array1, array2, dontConvert) {\u000a        var len = Math.min(array1.length, array2.length),\u000a            lengthDiff = Math.abs(array1.length - array2.length),\u000a            diffs = 0,\u000a            i;\u000a        for (i = 0; i < len; i++) {\u000a            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\u000a                diffs++;\u000a            }\u000a        }\u000a        return diffs + lengthDiff;\u000a    }\u000a\u000a    function warn(msg) {\u000a        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\u000a            console.warn('Deprecation warning: ' + msg);\u000a        }\u000a    }\u000a\u000a    function deprecate(msg, fn) {\u000a        var firstTime = true;\u000a\u000a        return extend(function () {\u000a            if (utils_hooks__hooks.deprecationHandler != null) {\u000a                utils_hooks__hooks.deprecationHandler(null, msg);\u000a            }\u000a            if (firstTime) {\u000a                warn(msg + '\u005cnArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\u005cn' + new Error().stack);\u000a                firstTime = false;\u000a            }\u000a            return fn.apply(this, arguments);\u000a        }, fn);\u000a    }\u000a\u000a    var deprecations = {};\u000a\u000a    function deprecateSimple(name, msg) {\u000a        if (utils_hooks__hooks.deprecationHandler != null) {\u000a            utils_hooks__hooks.deprecationHandler(name, msg);\u000a        }\u000a        if (!deprecations[name]) {\u000a            warn(msg);\u000a            deprecations[name] = true;\u000a        }\u000a    }\u000a\u000a    utils_hooks__hooks.suppressDeprecationWarnings = false;\u000a    utils_hooks__hooks.deprecationHandler = null;\u000a\u000a    function isFunction(input) {\u000a        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\u000a    }\u000a\u000a    function locale_set__set(config) {\u000a        var prop, i;\u000a        for (i in config) {\u000a            prop = config[i];\u000a            if (isFunction(prop)) {\u000a                this[i] = prop;\u000a            } else {\u000a                this['_' + i] = prop;\u000a            }\u000a        }\u000a        this._config = config;\u000a        // Lenient ordinal parsing accepts just a number in addition to\u000a        // number + (possibly) stuff coming from _ordinalParseLenient.\u000a        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\u005cd{1,2}/.source);\u000a    }\u000a\u000a    function mergeConfigs(parentConfig, childConfig) {\u000a        var res = extend({}, parentConfig),\u000a            prop;\u000a        for (prop in childConfig) {\u000a            if (hasOwnProp(childConfig, prop)) {\u000a                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\u000a                    res[prop] = {};\u000a                    extend(res[prop], parentConfig[prop]);\u000a                    extend(res[prop], childConfig[prop]);\u000a                } else if (childConfig[prop] != null) {\u000a                    res[prop] = childConfig[prop];\u000a                } else {\u000a                    delete res[prop];\u000a                }\u000a            }\u000a        }\u000a        for (prop in parentConfig) {\u000a            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\u000a                // make sure changes to properties don't modify parent config\u000a                res[prop] = extend({}, res[prop]);\u000a            }\u000a        }\u000a        return res;\u000a    }\u000a\u000a    function Locale(config) {\u000a        if (config != null) {\u000a            this.set(config);\u000a        }\u000a    }\u000a\u000a    var keys;\u000a\u000a    if (Object.keys) {\u000a        keys = Object.keys;\u000a    } else {\u000a        keys = function (obj) {\u000a            var i,\u000a                res = [];\u000a            for (i in obj) {\u000a                if (hasOwnProp(obj, i)) {\u000a                    res.push(i);\u000a                }\u000a            }\u000a            return res;\u000a        };\u000a    }\u000a\u000a    var defaultCalendar = {\u000a        sameDay: '[Today at] LT',\u000a        nextDay: '[Tomorrow at] LT',\u000a        nextWeek: 'dddd [at] LT',\u000a        lastDay: '[Yesterday at] LT',\u000a        lastWeek: '[Last] dddd [at] LT',\u000a        sameElse: 'L'\u000a    };\u000a\u000a    function locale_calendar__calendar(key, mom, now) {\u000a        var output = this._calendar[key] || this._calendar['sameElse'];\u000a        return isFunction(output) ? output.call(mom, now) : output;\u000a    }\u000a\u000a    var defaultLongDateFormat = {\u000a        LTS: 'h:mm:ss A',\u000a        LT: 'h:mm A',\u000a        L: 'MM/DD/YYYY',\u000a        LL: 'MMMM D, YYYY',\u000a        LLL: 'MMMM D, YYYY h:mm A',\u000a        LLLL: 'dddd, MMMM D, YYYY h:mm A'\u000a    };\u000a\u000a    function longDateFormat(key) {\u000a        var format = this._longDateFormat[key],\u000a            formatUpper = this._longDateFormat[key.toUpperCase()];\u000a\u000a        if (format || !formatUpper) {\u000a            return format;\u000a        }\u000a\u000a        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\u000a            return val.slice(1);\u000a        });\u000a\u000a        return this._longDateFormat[key];\u000a    }\u000a\u000a    var defaultInvalidDate = 'Invalid date';\u000a\u000a    function invalidDate() {\u000a        return this._invalidDate;\u000a    }\u000a\u000a    var defaultOrdinal = '%d';\u000a    var defaultOrdinalParse = /\u005cd{1,2}/;\u000a\u000a    function ordinal(number) {\u000a        return this._ordinal.replace('%d', number);\u000a    }\u000a\u000a    var defaultRelativeTime = {\u000a        future: 'in %s',\u000a        past: '%s ago',\u000a        s: 'a few seconds',\u000a        m: 'a minute',\u000a        mm: '%d minutes',\u000a        h: 'an hour',\u000a        hh: '%d hours',\u000a        d: 'a day',\u000a        dd: '%d days',\u000a        M: 'a month',\u000a        MM: '%d months',\u000a        y: 'a year',\u000a        yy: '%d years'\u000a    };\u000a\u000a    function relative__relativeTime(number, withoutSuffix, string, isFuture) {\u000a        var output = this._relativeTime[string];\u000a        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\u000a    }\u000a\u000a    function pastFuture(diff, output) {\u000a        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\u000a        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\u000a    }\u000a\u000a    var aliases = {};\u000a\u000a    function addUnitAlias(unit, shorthand) {\u000a        var lowerCase = unit.toLowerCase();\u000a        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\u000a    }\u000a\u000a    function normalizeUnits(units) {\u000a        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\u000a    }\u000a\u000a    function normalizeObjectUnits(inputObject) {\u000a        var normalizedInput = {},\u000a            normalizedProp,\u000a            prop;\u000a\u000a        for (prop in inputObject) {\u000a            if (hasOwnProp(inputObject, prop)) {\u000a                normalizedProp = normalizeUnits(prop);\u000a                if (normalizedProp) {\u000a                    normalizedInput[normalizedProp] = inputObject[prop];\u000a                }\u000a            }\u000a        }\u000a\u000a        return normalizedInput;\u000a    }\u000a\u000a    var priorities = {};\u000a\u000a    function addUnitPriority(unit, priority) {\u000a        priorities[unit] = priority;\u000a    }\u000a\u000a    function getPrioritizedUnits(unitsObj) {\u000a        var units = [];\u000a        for (var u in unitsObj) {\u000a            units.push({ unit: u, priority: priorities[u] });\u000a        }\u000a        units.sort(function (a, b) {\u000a            return a.priority - b.priority;\u000a        });\u000a        return units;\u000a    }\u000a\u000a    function makeGetSet(unit, keepTime) {\u000a        return function (value) {\u000a            if (value != null) {\u000a                get_set__set(this, unit, value);\u000a                utils_hooks__hooks.updateOffset(this, keepTime);\u000a                return this;\u000a            } else {\u000a                return get_set__get(this, unit);\u000a            }\u000a        };\u000a    }\u000a\u000a    function get_set__get(mom, unit) {\u000a        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\u000a    }\u000a\u000a    function get_set__set(mom, unit, value) {\u000a        if (mom.isValid()) {\u000a            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\u000a        }\u000a    }\u000a\u000a    // MOMENTS\u000a\u000a    function stringGet(units) {\u000a        units = normalizeUnits(units);\u000a        if (isFunction(this[units])) {\u000a            return this[units]();\u000a        }\u000a        return this;\u000a    }\u000a\u000a    function stringSet(units, value) {\u000a        if (typeof units === 'object') {\u000a            units = normalizeObjectUnits(units);\u000a            var prioritized = getPrioritizedUnits(units);\u000a            for (var i = 0; i < prioritized.length; i++) {\u000a                this[prioritized[i].unit](units[prioritized[i].unit]);\u000a            }\u000a        } else {\u000a            units = normalizeUnits(units);\u000a            if (isFunction(this[units])) {\u000a                return this[units](value);\u000a            }\u000a        }\u000a        return this;\u000a    }\u000a\u000a    function zeroFill(number, targetLength, forceSign) {\u000a        var absNumber = '' + Math.abs(number),\u000a            zerosToFill = targetLength - absNumber.length,\u000a            sign = number >= 0;\u000a        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\u000a    }\u000a\u000a    var formattingTokens = /(\u005c[[^\u005c[]*\u005c])|(\u005c\u005c)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\u000a\u000a    var localFormattingTokens = /(\u005c[[^\u005c[]*\u005c])|(\u005c\u005c)?(LTS|LT|LL?L?L?|l{1,4})/g;\u000a\u000a    var formatFunctions = {};\u000a\u000a    var formatTokenFunctions = {};\u000a\u000a    // token:    'M'\u000a    // padded:   ['MM', 2]\u000a    // ordinal:  'Mo'\u000a    // callback: function () { this.month() + 1 }\u000a    function addFormatToken(token, padded, ordinal, callback) {\u000a        var func = callback;\u000a        if (typeof callback === 'string') {\u000a            func = function () {\u000a                return this[callback]();\u000a            };\u000a        }\u000a        if (token) {\u000a            formatTokenFunctions[token] = func;\u000a        }\u000a        if (padded) {\u000a            formatTokenFunctions[padded[0]] = function () {\u000a                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\u000a            };\u000a        }\u000a        if (ordinal) {\u000a            formatTokenFunctions[ordinal] = function () {\u000a                return this.localeData().ordinal(func.apply(this, arguments), token);\u000a            };\u000a        }\u000a    }\u000a\u000a    function removeFormattingTokens(input) {\u000a        if (input.match(/\u005c[[\u005cs\u005cS]/)) {\u000a            return input.replace(/^\u005c[|\u005c]$/g, '');\u000a        }\u000a        return input.replace(/\u005c\u005c/g, '');\u000a    }\u000a\u000a    function makeFormatFunction(format) {\u000a        var array = format.match(formattingTokens),\u000a            i,\u000a            length;\u000a\u000a        for (i = 0, length = array.length; i < length; i++) {\u000a            if (formatTokenFunctions[array[i]]) {\u000a                array[i] = formatTokenFunctions[array[i]];\u000a            } else {\u000a                array[i] = removeFormattingTokens(array[i]);\u000a            }\u000a        }\u000a\u000a        return function (mom) {\u000a            var output = '',\u000a                i;\u000a            for (i = 0; i < length; i++) {\u000a                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\u000a            }\u000a            return output;\u000a        };\u000a    }\u000a\u000a    // format date using native date object\u000a    function formatMoment(m, format) {\u000a        if (!m.isValid()) {\u000a            return m.localeData().invalidDate();\u000a        }\u000a\u000a        format = expandFormat(format, m.localeData());\u000a        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\u000a\u000a        return formatFunctions[format](m);\u000a    }\u000a\u000a    function expandFormat(format, locale) {\u000a        var i = 5;\u000a\u000a        function replaceLongDateFormatTokens(input) {\u000a            return locale.longDateFormat(input) || input;\u000a        }\u000a\u000a        localFormattingTokens.lastIndex = 0;\u000a        while (i >= 0 && localFormattingTokens.test(format)) {\u000a            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\u000a            localFormattingTokens.lastIndex = 0;\u000a            i -= 1;\u000a        }\u000a\u000a        return format;\u000a    }\u000a\u000a    var match1 = /\u005cd/; //       0 - 9\u000a    var match2 = /\u005cd\u005cd/; //      00 - 99\u000a    var match3 = /\u005cd{3}/; //     000 - 999\u000a    var match4 = /\u005cd{4}/; //    0000 - 9999\u000a    var match6 = /[+-]?\u005cd{6}/; // -999999 - 999999\u000a    var match1to2 = /\u005cd\u005cd?/; //       0 - 99\u000a    var match3to4 = /\u005cd\u005cd\u005cd\u005cd?/; //     999 - 9999\u000a    var match5to6 = /\u005cd\u005cd\u005cd\u005cd\u005cd\u005cd?/; //   99999 - 999999\u000a    var match1to3 = /\u005cd{1,3}/; //       0 - 999\u000a    var match1to4 = /\u005cd{1,4}/; //       0 - 9999\u000a    var match1to6 = /[+-]?\u005cd{1,6}/; // -999999 - 999999\u000a\u000a    var matchUnsigned = /\u005cd+/; //       0 - inf\u000a    var matchSigned = /[+-]?\u005cd+/; //    -inf - inf\u000a\u000a    var matchOffset = /Z|[+-]\u005cd\u005cd:?\u005cd\u005cd/gi; // +00:00 -00:00 +0000 -0000 or Z\u000a    var matchShortOffset = /Z|[+-]\u005cd\u005cd(?::?\u005cd\u005cd)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\u000a\u000a    var matchTimestamp = /[+-]?\u005cd+(\u005c.\u005cd{1,3})?/; // 123456789 123456789.123\u000a\u000a    // any word (or two) characters or numbers including two/three word month in arabic.\u000a    // includes scottish gaelic two word and hyphenated months\u000a    var matchWord = /[0-9]*['a-z\u005cu00A0-\u005cu05FF\u005cu0700-\u005cuD7FF\u005cuF900-\u005cuFDCF\u005cuFDF0-\u005cuFFEF]+|[\u005cu0600-\u005cu06FF\u005c/]+(\u005cs*?[\u005cu0600-\u005cu06FF]+){1,2}/i;\u000a\u000a    var regexes = {};\u000a\u000a    function addRegexToken(token, regex, strictRegex) {\u000a        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\u000a            return isStrict && strictRegex ? strictRegex : regex;\u000a        };\u000a    }\u000a\u000a    function getParseRegexForToken(token, config) {\u000a        if (!hasOwnProp(regexes, token)) {\u000a            return new RegExp(unescapeFormat(token));\u000a        }\u000a\u000a        return regexes[token](config._strict, config._locale);\u000a    }\u000a\u000a    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\u000a    function unescapeFormat(s) {\u000a        return regexEscape(s.replace('\u005c\u005c', '').replace(/\u005c\u005c(\u005c[)|\u005c\u005c(\u005c])|\u005c[([^\u005c]\u005c[]*)\u005c]|\u005c\u005c(.)/g, function (matched, p1, p2, p3, p4) {\u000a            return p1 || p2 || p3 || p4;\u000a        }));\u000a    }\u000a\u000a    function regexEscape(s) {\u000a        return s.replace(/[-\u005c/\u005c\u005c^$*+?.()|[\u005c]{}]/g, '\u005c\u005c$&');\u000a    }\u000a\u000a    var tokens = {};\u000a\u000a    function addParseToken(token, callback) {\u000a        var i,\u000a            func = callback;\u000a        if (typeof token === 'string') {\u000a            token = [token];\u000a        }\u000a        if (typeof callback === 'number') {\u000a            func = function (input, array) {\u000a                array[callback] = toInt(input);\u000a            };\u000a        }\u000a        for (i = 0; i < token.length; i++) {\u000a            tokens[token[i]] = func;\u000a        }\u000a    }\u000a\u000a    function addWeekParseToken(token, callback) {\u000a        addParseToken(token, function (input, array, config, token) {\u000a            config._w = config._w || {};\u000a            callback(input, config._w, config, token);\u000a        });\u000a    }\u000a\u000a    function addTimeToArrayFromToken(token, input, config) {\u000a        if (input != null && hasOwnProp(tokens, token)) {\u000a            tokens[token](input, config._a, config, token);\u000a        }\u000a    }\u000a\u000a    var YEAR = 0;\u000a    var MONTH = 1;\u000a    var DATE = 2;\u000a    var HOUR = 3;\u000a    var MINUTE = 4;\u000a    var SECOND = 5;\u000a    var MILLISECOND = 6;\u000a    var WEEK = 7;\u000a    var WEEKDAY = 8;\u000a\u000a    var indexOf;\u000a\u000a    if (Array.prototype.indexOf) {\u000a        indexOf = Array.prototype.indexOf;\u000a    } else {\u000a        indexOf = function (o) {\u000a            // I know\u000a            var i;\u000a            for (i = 0; i < this.length; ++i) {\u000a                if (this[i] === o) {\u000a                    return i;\u000a                }\u000a            }\u000a            return -1;\u000a        };\u000a    }\u000a\u000a    function daysInMonth(year, month) {\u000a        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('M', ['MM', 2], 'Mo', function () {\u000a        return this.month() + 1;\u000a    });\u000a\u000a    addFormatToken('MMM', 0, 0, function (format) {\u000a        return this.localeData().monthsShort(this, format);\u000a    });\u000a\u000a    addFormatToken('MMMM', 0, 0, function (format) {\u000a        return this.localeData().months(this, format);\u000a    });\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('month', 'M');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('month', 8);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('M', match1to2);\u000a    addRegexToken('MM', match1to2, match2);\u000a    addRegexToken('MMM', function (isStrict, locale) {\u000a        return locale.monthsShortRegex(isStrict);\u000a    });\u000a    addRegexToken('MMMM', function (isStrict, locale) {\u000a        return locale.monthsRegex(isStrict);\u000a    });\u000a\u000a    addParseToken(['M', 'MM'], function (input, array) {\u000a        array[MONTH] = toInt(input) - 1;\u000a    });\u000a\u000a    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\u000a        var month = config._locale.monthsParse(input, token, config._strict);\u000a        // if we didn't find a month name, mark the date as invalid.\u000a        if (month != null) {\u000a            array[MONTH] = month;\u000a        } else {\u000a            getParsingFlags(config).invalidMonth = input;\u000a        }\u000a    });\u000a\u000a    // LOCALES\u000a\u000a    var MONTHS_IN_FORMAT = /D[oD]?(\u005c[[^\u005c[\u005c]]*\u005c]|\u005cs+)+MMMM?/;\u000a    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\u000a    function localeMonths(m, format) {\u000a        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\u000a    }\u000a\u000a    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\u000a    function localeMonthsShort(m, format) {\u000a        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\u000a    }\u000a\u000a    function units_month__handleStrictParse(monthName, format, strict) {\u000a        var i,\u000a            ii,\u000a            mom,\u000a            llc = monthName.toLocaleLowerCase();\u000a        if (!this._monthsParse) {\u000a            // this is not used\u000a            this._monthsParse = [];\u000a            this._longMonthsParse = [];\u000a            this._shortMonthsParse = [];\u000a            for (i = 0; i < 12; ++i) {\u000a                mom = create_utc__createUTC([2000, i]);\u000a                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\u000a                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\u000a            }\u000a        }\u000a\u000a        if (strict) {\u000a            if (format === 'MMM') {\u000a                ii = indexOf.call(this._shortMonthsParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else {\u000a                ii = indexOf.call(this._longMonthsParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            }\u000a        } else {\u000a            if (format === 'MMM') {\u000a                ii = indexOf.call(this._shortMonthsParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._longMonthsParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else {\u000a                ii = indexOf.call(this._longMonthsParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._shortMonthsParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            }\u000a        }\u000a    }\u000a\u000a    function localeMonthsParse(monthName, format, strict) {\u000a        var i, mom, regex;\u000a\u000a        if (this._monthsParseExact) {\u000a            return units_month__handleStrictParse.call(this, monthName, format, strict);\u000a        }\u000a\u000a        if (!this._monthsParse) {\u000a            this._monthsParse = [];\u000a            this._longMonthsParse = [];\u000a            this._shortMonthsParse = [];\u000a        }\u000a\u000a        // TODO: add sorting\u000a        // Sorting makes sure if one month (or abbr) is a prefix of another\u000a        // see sorting in computeMonthsParse\u000a        for (i = 0; i < 12; i++) {\u000a            // make the regex if we don't have it already\u000a            mom = create_utc__createUTC([2000, i]);\u000a            if (strict && !this._longMonthsParse[i]) {\u000a                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\u000a                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\u000a            }\u000a            if (!strict && !this._monthsParse[i]) {\u000a                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\u000a                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\u000a            }\u000a            // test the regex\u000a            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\u000a                return i;\u000a            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\u000a                return i;\u000a            } else if (!strict && this._monthsParse[i].test(monthName)) {\u000a                return i;\u000a            }\u000a        }\u000a    }\u000a\u000a    // MOMENTS\u000a\u000a    function setMonth(mom, value) {\u000a        var dayOfMonth;\u000a\u000a        if (!mom.isValid()) {\u000a            // No op\u000a            return mom;\u000a        }\u000a\u000a        if (typeof value === 'string') {\u000a            if (/^\u005cd+$/.test(value)) {\u000a                value = toInt(value);\u000a            } else {\u000a                value = mom.localeData().monthsParse(value);\u000a                // TODO: Another silent failure?\u000a                if (typeof value !== 'number') {\u000a                    return mom;\u000a                }\u000a            }\u000a        }\u000a\u000a        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\u000a        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\u000a        return mom;\u000a    }\u000a\u000a    function getSetMonth(value) {\u000a        if (value != null) {\u000a            setMonth(this, value);\u000a            utils_hooks__hooks.updateOffset(this, true);\u000a            return this;\u000a        } else {\u000a            return get_set__get(this, 'Month');\u000a        }\u000a    }\u000a\u000a    function getDaysInMonth() {\u000a        return daysInMonth(this.year(), this.month());\u000a    }\u000a\u000a    var defaultMonthsShortRegex = matchWord;\u000a    function monthsShortRegex(isStrict) {\u000a        if (this._monthsParseExact) {\u000a            if (!hasOwnProp(this, '_monthsRegex')) {\u000a                computeMonthsParse.call(this);\u000a            }\u000a            if (isStrict) {\u000a                return this._monthsShortStrictRegex;\u000a            } else {\u000a                return this._monthsShortRegex;\u000a            }\u000a        } else {\u000a            if (!hasOwnProp(this, '_monthsShortRegex')) {\u000a                this._monthsShortRegex = defaultMonthsShortRegex;\u000a            }\u000a            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\u000a        }\u000a    }\u000a\u000a    var defaultMonthsRegex = matchWord;\u000a    function monthsRegex(isStrict) {\u000a        if (this._monthsParseExact) {\u000a            if (!hasOwnProp(this, '_monthsRegex')) {\u000a                computeMonthsParse.call(this);\u000a            }\u000a            if (isStrict) {\u000a                return this._monthsStrictRegex;\u000a            } else {\u000a                return this._monthsRegex;\u000a            }\u000a        } else {\u000a            if (!hasOwnProp(this, '_monthsRegex')) {\u000a                this._monthsRegex = defaultMonthsRegex;\u000a            }\u000a            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\u000a        }\u000a    }\u000a\u000a    function computeMonthsParse() {\u000a        function cmpLenRev(a, b) {\u000a            return b.length - a.length;\u000a        }\u000a\u000a        var shortPieces = [],\u000a            longPieces = [],\u000a            mixedPieces = [],\u000a            i,\u000a            mom;\u000a        for (i = 0; i < 12; i++) {\u000a            // make the regex if we don't have it already\u000a            mom = create_utc__createUTC([2000, i]);\u000a            shortPieces.push(this.monthsShort(mom, ''));\u000a            longPieces.push(this.months(mom, ''));\u000a            mixedPieces.push(this.months(mom, ''));\u000a            mixedPieces.push(this.monthsShort(mom, ''));\u000a        }\u000a        // Sorting makes sure if one month (or abbr) is a prefix of another it\u000a        // will match the longer piece.\u000a        shortPieces.sort(cmpLenRev);\u000a        longPieces.sort(cmpLenRev);\u000a        mixedPieces.sort(cmpLenRev);\u000a        for (i = 0; i < 12; i++) {\u000a            shortPieces[i] = regexEscape(shortPieces[i]);\u000a            longPieces[i] = regexEscape(longPieces[i]);\u000a        }\u000a        for (i = 0; i < 24; i++) {\u000a            mixedPieces[i] = regexEscape(mixedPieces[i]);\u000a        }\u000a\u000a        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\u000a        this._monthsShortRegex = this._monthsRegex;\u000a        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\u000a        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('Y', 0, 0, function () {\u000a        var y = this.year();\u000a        return y <= 9999 ? '' + y : '+' + y;\u000a    });\u000a\u000a    addFormatToken(0, ['YY', 2], 0, function () {\u000a        return this.year() % 100;\u000a    });\u000a\u000a    addFormatToken(0, ['YYYY', 4], 0, 'year');\u000a    addFormatToken(0, ['YYYYY', 5], 0, 'year');\u000a    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('year', 'y');\u000a\u000a    // PRIORITIES\u000a\u000a    addUnitPriority('year', 1);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('Y', matchSigned);\u000a    addRegexToken('YY', match1to2, match2);\u000a    addRegexToken('YYYY', match1to4, match4);\u000a    addRegexToken('YYYYY', match1to6, match6);\u000a    addRegexToken('YYYYYY', match1to6, match6);\u000a\u000a    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\u000a    addParseToken('YYYY', function (input, array) {\u000a        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);\u000a    });\u000a    addParseToken('YY', function (input, array) {\u000a        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);\u000a    });\u000a    addParseToken('Y', function (input, array) {\u000a        array[YEAR] = parseInt(input, 10);\u000a    });\u000a\u000a    // HELPERS\u000a\u000a    function daysInYear(year) {\u000a        return isLeapYear(year) ? 366 : 365;\u000a    }\u000a\u000a    function isLeapYear(year) {\u000a        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\u000a    }\u000a\u000a    // HOOKS\u000a\u000a    utils_hooks__hooks.parseTwoDigitYear = function (input) {\u000a        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\u000a    };\u000a\u000a    // MOMENTS\u000a\u000a    var getSetYear = makeGetSet('FullYear', true);\u000a\u000a    function getIsLeapYear() {\u000a        return isLeapYear(this.year());\u000a    }\u000a\u000a    function createDate(y, m, d, h, M, s, ms) {\u000a        //can't just apply() to create a date:\u000a        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\u000a        var date = new Date(y, m, d, h, M, s, ms);\u000a\u000a        //the date constructor remaps years 0-99 to 1900-1999\u000a        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\u000a            date.setFullYear(y);\u000a        }\u000a        return date;\u000a    }\u000a\u000a    function createUTCDate(y) {\u000a        var date = new Date(Date.UTC.apply(null, arguments));\u000a\u000a        //the Date.UTC function remaps years 0-99 to 1900-1999\u000a        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\u000a            date.setUTCFullYear(y);\u000a        }\u000a        return date;\u000a    }\u000a\u000a    // start-of-first-week - start-of-year\u000a    function firstWeekOffset(year, dow, doy) {\u000a        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\u000a        fwd = 7 + dow - doy,\u000a\u000a        // first-week day local weekday -- which local weekday is fwd\u000a        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\u000a\u000a        return -fwdlw + fwd - 1;\u000a    }\u000a\u000a    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\u000a    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\u000a        var localWeekday = (7 + weekday - dow) % 7,\u000a            weekOffset = firstWeekOffset(year, dow, doy),\u000a            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\u000a            resYear,\u000a            resDayOfYear;\u000a\u000a        if (dayOfYear <= 0) {\u000a            resYear = year - 1;\u000a            resDayOfYear = daysInYear(resYear) + dayOfYear;\u000a        } else if (dayOfYear > daysInYear(year)) {\u000a            resYear = year + 1;\u000a            resDayOfYear = dayOfYear - daysInYear(year);\u000a        } else {\u000a            resYear = year;\u000a            resDayOfYear = dayOfYear;\u000a        }\u000a\u000a        return {\u000a            year: resYear,\u000a            dayOfYear: resDayOfYear\u000a        };\u000a    }\u000a\u000a    function weekOfYear(mom, dow, doy) {\u000a        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\u000a            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\u000a            resWeek,\u000a            resYear;\u000a\u000a        if (week < 1) {\u000a            resYear = mom.year() - 1;\u000a            resWeek = week + weeksInYear(resYear, dow, doy);\u000a        } else if (week > weeksInYear(mom.year(), dow, doy)) {\u000a            resWeek = week - weeksInYear(mom.year(), dow, doy);\u000a            resYear = mom.year() + 1;\u000a        } else {\u000a            resYear = mom.year();\u000a            resWeek = week;\u000a        }\u000a\u000a        return {\u000a            week: resWeek,\u000a            year: resYear\u000a        };\u000a    }\u000a\u000a    function weeksInYear(year, dow, doy) {\u000a        var weekOffset = firstWeekOffset(year, dow, doy),\u000a            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\u000a        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('w', ['ww', 2], 'wo', 'week');\u000a    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('week', 'w');\u000a    addUnitAlias('isoWeek', 'W');\u000a\u000a    // PRIORITIES\u000a\u000a    addUnitPriority('week', 5);\u000a    addUnitPriority('isoWeek', 5);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('w', match1to2);\u000a    addRegexToken('ww', match1to2, match2);\u000a    addRegexToken('W', match1to2);\u000a    addRegexToken('WW', match1to2, match2);\u000a\u000a    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\u000a        week[token.substr(0, 1)] = toInt(input);\u000a    });\u000a\u000a    // HELPERS\u000a\u000a    // LOCALES\u000a\u000a    function localeWeek(mom) {\u000a        return weekOfYear(mom, this._week.dow, this._week.doy).week;\u000a    }\u000a\u000a    var defaultLocaleWeek = {\u000a        dow: 0, // Sunday is the first day of the week.\u000a        doy: 6 // The week that contains Jan 1st is the first week of the year.\u000a    };\u000a\u000a    function localeFirstDayOfWeek() {\u000a        return this._week.dow;\u000a    }\u000a\u000a    function localeFirstDayOfYear() {\u000a        return this._week.doy;\u000a    }\u000a\u000a    // MOMENTS\u000a\u000a    function getSetWeek(input) {\u000a        var week = this.localeData().week(this);\u000a        return input == null ? week : this.add((input - week) * 7, 'd');\u000a    }\u000a\u000a    function getSetISOWeek(input) {\u000a        var week = weekOfYear(this, 1, 4).week;\u000a        return input == null ? week : this.add((input - week) * 7, 'd');\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('d', 0, 'do', 'day');\u000a\u000a    addFormatToken('dd', 0, 0, function (format) {\u000a        return this.localeData().weekdaysMin(this, format);\u000a    });\u000a\u000a    addFormatToken('ddd', 0, 0, function (format) {\u000a        return this.localeData().weekdaysShort(this, format);\u000a    });\u000a\u000a    addFormatToken('dddd', 0, 0, function (format) {\u000a        return this.localeData().weekdays(this, format);\u000a    });\u000a\u000a    addFormatToken('e', 0, 0, 'weekday');\u000a    addFormatToken('E', 0, 0, 'isoWeekday');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('day', 'd');\u000a    addUnitAlias('weekday', 'e');\u000a    addUnitAlias('isoWeekday', 'E');\u000a\u000a    // PRIORITY\u000a    addUnitPriority('day', 11);\u000a    addUnitPriority('weekday', 11);\u000a    addUnitPriority('isoWeekday', 11);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('d', match1to2);\u000a    addRegexToken('e', match1to2);\u000a    addRegexToken('E', match1to2);\u000a    addRegexToken('dd', function (isStrict, locale) {\u000a        return locale.weekdaysMinRegex(isStrict);\u000a    });\u000a    addRegexToken('ddd', function (isStrict, locale) {\u000a        return locale.weekdaysShortRegex(isStrict);\u000a    });\u000a    addRegexToken('dddd', function (isStrict, locale) {\u000a        return locale.weekdaysRegex(isStrict);\u000a    });\u000a\u000a    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\u000a        var weekday = config._locale.weekdaysParse(input, token, config._strict);\u000a        // if we didn't get a weekday name, mark the date as invalid\u000a        if (weekday != null) {\u000a            week.d = weekday;\u000a        } else {\u000a            getParsingFlags(config).invalidWeekday = input;\u000a        }\u000a    });\u000a\u000a    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\u000a        week[token] = toInt(input);\u000a    });\u000a\u000a    // HELPERS\u000a\u000a    function parseWeekday(input, locale) {\u000a        if (typeof input !== 'string') {\u000a            return input;\u000a        }\u000a\u000a        if (!isNaN(input)) {\u000a            return parseInt(input, 10);\u000a        }\u000a\u000a        input = locale.weekdaysParse(input);\u000a        if (typeof input === 'number') {\u000a            return input;\u000a        }\u000a\u000a        return null;\u000a    }\u000a\u000a    function parseIsoWeekday(input, locale) {\u000a        if (typeof input === 'string') {\u000a            return locale.weekdaysParse(input) % 7 || 7;\u000a        }\u000a        return isNaN(input) ? null : input;\u000a    }\u000a\u000a    // LOCALES\u000a\u000a    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\u000a    function localeWeekdays(m, format) {\u000a        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\u000a    }\u000a\u000a    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\u000a    function localeWeekdaysShort(m) {\u000a        return this._weekdaysShort[m.day()];\u000a    }\u000a\u000a    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\u000a    function localeWeekdaysMin(m) {\u000a        return this._weekdaysMin[m.day()];\u000a    }\u000a\u000a    function day_of_week__handleStrictParse(weekdayName, format, strict) {\u000a        var i,\u000a            ii,\u000a            mom,\u000a            llc = weekdayName.toLocaleLowerCase();\u000a        if (!this._weekdaysParse) {\u000a            this._weekdaysParse = [];\u000a            this._shortWeekdaysParse = [];\u000a            this._minWeekdaysParse = [];\u000a\u000a            for (i = 0; i < 7; ++i) {\u000a                mom = create_utc__createUTC([2000, 1]).day(i);\u000a                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\u000a                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\u000a                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\u000a            }\u000a        }\u000a\u000a        if (strict) {\u000a            if (format === 'dddd') {\u000a                ii = indexOf.call(this._weekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else if (format === 'ddd') {\u000a                ii = indexOf.call(this._shortWeekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else {\u000a                ii = indexOf.call(this._minWeekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            }\u000a        } else {\u000a            if (format === 'dddd') {\u000a                ii = indexOf.call(this._weekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._shortWeekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._minWeekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else if (format === 'ddd') {\u000a                ii = indexOf.call(this._shortWeekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._weekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._minWeekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            } else {\u000a                ii = indexOf.call(this._minWeekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._weekdaysParse, llc);\u000a                if (ii !== -1) {\u000a                    return ii;\u000a                }\u000a                ii = indexOf.call(this._shortWeekdaysParse, llc);\u000a                return ii !== -1 ? ii : null;\u000a            }\u000a        }\u000a    }\u000a\u000a    function localeWeekdaysParse(weekdayName, format, strict) {\u000a        var i, mom, regex;\u000a\u000a        if (this._weekdaysParseExact) {\u000a            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);\u000a        }\u000a\u000a        if (!this._weekdaysParse) {\u000a            this._weekdaysParse = [];\u000a            this._minWeekdaysParse = [];\u000a            this._shortWeekdaysParse = [];\u000a            this._fullWeekdaysParse = [];\u000a        }\u000a\u000a        for (i = 0; i < 7; i++) {\u000a            // make the regex if we don't have it already\u000a\u000a            mom = create_utc__createUTC([2000, 1]).day(i);\u000a            if (strict && !this._fullWeekdaysParse[i]) {\u000a                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\u005c.?') + '$', 'i');\u000a                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\u005c.?') + '$', 'i');\u000a                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\u005c.?') + '$', 'i');\u000a            }\u000a            if (!this._weekdaysParse[i]) {\u000a                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\u000a                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\u000a            }\u000a            // test the regex\u000a            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\u000a                return i;\u000a            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\u000a                return i;\u000a            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\u000a                return i;\u000a            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\u000a                return i;\u000a            }\u000a        }\u000a    }\u000a\u000a    // MOMENTS\u000a\u000a    function getSetDayOfWeek(input) {\u000a        if (!this.isValid()) {\u000a            return input != null ? this : NaN;\u000a        }\u000a        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\u000a        if (input != null) {\u000a            input = parseWeekday(input, this.localeData());\u000a            return this.add(input - day, 'd');\u000a        } else {\u000a            return day;\u000a        }\u000a    }\u000a\u000a    function getSetLocaleDayOfWeek(input) {\u000a        if (!this.isValid()) {\u000a            return input != null ? this : NaN;\u000a        }\u000a        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\u000a        return input == null ? weekday : this.add(input - weekday, 'd');\u000a    }\u000a\u000a    function getSetISODayOfWeek(input) {\u000a        if (!this.isValid()) {\u000a            return input != null ? this : NaN;\u000a        }\u000a\u000a        // behaves the same as moment#day except\u000a        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\u000a        // as a setter, sunday should belong to the previous week.\u000a\u000a        if (input != null) {\u000a            var weekday = parseIsoWeekday(input, this.localeData());\u000a            return this.day(this.day() % 7 ? weekday : weekday - 7);\u000a        } else {\u000a            return this.day() || 7;\u000a        }\u000a    }\u000a\u000a    var defaultWeekdaysRegex = matchWord;\u000a    function weekdaysRegex(isStrict) {\u000a        if (this._weekdaysParseExact) {\u000a            if (!hasOwnProp(this, '_weekdaysRegex')) {\u000a                computeWeekdaysParse.call(this);\u000a            }\u000a            if (isStrict) {\u000a                return this._weekdaysStrictRegex;\u000a            } else {\u000a                return this._weekdaysRegex;\u000a            }\u000a        } else {\u000a            if (!hasOwnProp(this, '_weekdaysRegex')) {\u000a                this._weekdaysRegex = defaultWeekdaysRegex;\u000a            }\u000a            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\u000a        }\u000a    }\u000a\u000a    var defaultWeekdaysShortRegex = matchWord;\u000a    function weekdaysShortRegex(isStrict) {\u000a        if (this._weekdaysParseExact) {\u000a            if (!hasOwnProp(this, '_weekdaysRegex')) {\u000a                computeWeekdaysParse.call(this);\u000a            }\u000a            if (isStrict) {\u000a                return this._weekdaysShortStrictRegex;\u000a            } else {\u000a                return this._weekdaysShortRegex;\u000a            }\u000a        } else {\u000a            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\u000a                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\u000a            }\u000a            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\u000a        }\u000a    }\u000a\u000a    var defaultWeekdaysMinRegex = matchWord;\u000a    function weekdaysMinRegex(isStrict) {\u000a        if (this._weekdaysParseExact) {\u000a            if (!hasOwnProp(this, '_weekdaysRegex')) {\u000a                computeWeekdaysParse.call(this);\u000a            }\u000a            if (isStrict) {\u000a                return this._weekdaysMinStrictRegex;\u000a            } else {\u000a                return this._weekdaysMinRegex;\u000a            }\u000a        } else {\u000a            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\u000a                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\u000a            }\u000a            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\u000a        }\u000a    }\u000a\u000a    function computeWeekdaysParse() {\u000a        function cmpLenRev(a, b) {\u000a            return b.length - a.length;\u000a        }\u000a\u000a        var minPieces = [],\u000a            shortPieces = [],\u000a            longPieces = [],\u000a            mixedPieces = [],\u000a            i,\u000a            mom,\u000a            minp,\u000a            shortp,\u000a            longp;\u000a        for (i = 0; i < 7; i++) {\u000a            // make the regex if we don't have it already\u000a            mom = create_utc__createUTC([2000, 1]).day(i);\u000a            minp = this.weekdaysMin(mom, '');\u000a            shortp = this.weekdaysShort(mom, '');\u000a            longp = this.weekdays(mom, '');\u000a            minPieces.push(minp);\u000a            shortPieces.push(shortp);\u000a            longPieces.push(longp);\u000a            mixedPieces.push(minp);\u000a            mixedPieces.push(shortp);\u000a            mixedPieces.push(longp);\u000a        }\u000a        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\u000a        // will match the longer piece.\u000a        minPieces.sort(cmpLenRev);\u000a        shortPieces.sort(cmpLenRev);\u000a        longPieces.sort(cmpLenRev);\u000a        mixedPieces.sort(cmpLenRev);\u000a        for (i = 0; i < 7; i++) {\u000a            shortPieces[i] = regexEscape(shortPieces[i]);\u000a            longPieces[i] = regexEscape(longPieces[i]);\u000a            mixedPieces[i] = regexEscape(mixedPieces[i]);\u000a        }\u000a\u000a        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\u000a        this._weekdaysShortRegex = this._weekdaysRegex;\u000a        this._weekdaysMinRegex = this._weekdaysRegex;\u000a\u000a        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\u000a        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\u000a        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    function hFormat() {\u000a        return this.hours() % 12 || 12;\u000a    }\u000a\u000a    function kFormat() {\u000a        return this.hours() || 24;\u000a    }\u000a\u000a    addFormatToken('H', ['HH', 2], 0, 'hour');\u000a    addFormatToken('h', ['hh', 2], 0, hFormat);\u000a    addFormatToken('k', ['kk', 2], 0, kFormat);\u000a\u000a    addFormatToken('hmm', 0, 0, function () {\u000a        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\u000a    });\u000a\u000a    addFormatToken('hmmss', 0, 0, function () {\u000a        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\u000a    });\u000a\u000a    addFormatToken('Hmm', 0, 0, function () {\u000a        return '' + this.hours() + zeroFill(this.minutes(), 2);\u000a    });\u000a\u000a    addFormatToken('Hmmss', 0, 0, function () {\u000a        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\u000a    });\u000a\u000a    function meridiem(token, lowercase) {\u000a        addFormatToken(token, 0, 0, function () {\u000a            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\u000a        });\u000a    }\u000a\u000a    meridiem('a', true);\u000a    meridiem('A', false);\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('hour', 'h');\u000a\u000a    // PRIORITY\u000a    addUnitPriority('hour', 13);\u000a\u000a    // PARSING\u000a\u000a    function matchMeridiem(isStrict, locale) {\u000a        return locale._meridiemParse;\u000a    }\u000a\u000a    addRegexToken('a', matchMeridiem);\u000a    addRegexToken('A', matchMeridiem);\u000a    addRegexToken('H', match1to2);\u000a    addRegexToken('h', match1to2);\u000a    addRegexToken('HH', match1to2, match2);\u000a    addRegexToken('hh', match1to2, match2);\u000a\u000a    addRegexToken('hmm', match3to4);\u000a    addRegexToken('hmmss', match5to6);\u000a    addRegexToken('Hmm', match3to4);\u000a    addRegexToken('Hmmss', match5to6);\u000a\u000a    addParseToken(['H', 'HH'], HOUR);\u000a    addParseToken(['a', 'A'], function (input, array, config) {\u000a        config._isPm = config._locale.isPM(input);\u000a        config._meridiem = input;\u000a    });\u000a    addParseToken(['h', 'hh'], function (input, array, config) {\u000a        array[HOUR] = toInt(input);\u000a        getParsingFlags(config).bigHour = true;\u000a    });\u000a    addParseToken('hmm', function (input, array, config) {\u000a        var pos = input.length - 2;\u000a        array[HOUR] = toInt(input.substr(0, pos));\u000a        array[MINUTE] = toInt(input.substr(pos));\u000a        getParsingFlags(config).bigHour = true;\u000a    });\u000a    addParseToken('hmmss', function (input, array, config) {\u000a        var pos1 = input.length - 4;\u000a        var pos2 = input.length - 2;\u000a        array[HOUR] = toInt(input.substr(0, pos1));\u000a        array[MINUTE] = toInt(input.substr(pos1, 2));\u000a        array[SECOND] = toInt(input.substr(pos2));\u000a        getParsingFlags(config).bigHour = true;\u000a    });\u000a    addParseToken('Hmm', function (input, array, config) {\u000a        var pos = input.length - 2;\u000a        array[HOUR] = toInt(input.substr(0, pos));\u000a        array[MINUTE] = toInt(input.substr(pos));\u000a    });\u000a    addParseToken('Hmmss', function (input, array, config) {\u000a        var pos1 = input.length - 4;\u000a        var pos2 = input.length - 2;\u000a        array[HOUR] = toInt(input.substr(0, pos1));\u000a        array[MINUTE] = toInt(input.substr(pos1, 2));\u000a        array[SECOND] = toInt(input.substr(pos2));\u000a    });\u000a\u000a    // LOCALES\u000a\u000a    function localeIsPM(input) {\u000a        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\u000a        // Using charAt should be more compatible.\u000a        return (input + '').toLowerCase().charAt(0) === 'p';\u000a    }\u000a\u000a    var defaultLocaleMeridiemParse = /[ap]\u005c.?m?\u005c.?/i;\u000a    function localeMeridiem(hours, minutes, isLower) {\u000a        if (hours > 11) {\u000a            return isLower ? 'pm' : 'PM';\u000a        } else {\u000a            return isLower ? 'am' : 'AM';\u000a        }\u000a    }\u000a\u000a    // MOMENTS\u000a\u000a    // Setting the hour should keep the time, because the user explicitly\u000a    // specified which hour he wants. So trying to maintain the same hour (in\u000a    // a new timezone) makes sense. Adding/subtracting hours does not follow\u000a    // this rule.\u000a    var getSetHour = makeGetSet('Hours', true);\u000a\u000a    var baseConfig = {\u000a        calendar: defaultCalendar,\u000a        longDateFormat: defaultLongDateFormat,\u000a        invalidDate: defaultInvalidDate,\u000a        ordinal: defaultOrdinal,\u000a        ordinalParse: defaultOrdinalParse,\u000a        relativeTime: defaultRelativeTime,\u000a\u000a        months: defaultLocaleMonths,\u000a        monthsShort: defaultLocaleMonthsShort,\u000a\u000a        week: defaultLocaleWeek,\u000a\u000a        weekdays: defaultLocaleWeekdays,\u000a        weekdaysMin: defaultLocaleWeekdaysMin,\u000a        weekdaysShort: defaultLocaleWeekdaysShort,\u000a\u000a        meridiemParse: defaultLocaleMeridiemParse\u000a    };\u000a\u000a    // internal storage for locale config files\u000a    var locales = {};\u000a    var globalLocale;\u000a\u000a    function normalizeLocale(key) {\u000a        return key ? key.toLowerCase().replace('_', '-') : key;\u000a    }\u000a\u000a    // pick the locale from the array\u000a    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\u000a    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\u000a    function chooseLocale(names) {\u000a        var i = 0,\u000a            j,\u000a            next,\u000a            locale,\u000a            split;\u000a\u000a        while (i < names.length) {\u000a            split = normalizeLocale(names[i]).split('-');\u000a            j = split.length;\u000a            next = normalizeLocale(names[i + 1]);\u000a            next = next ? next.split('-') : null;\u000a            while (j > 0) {\u000a                locale = loadLocale(split.slice(0, j).join('-'));\u000a                if (locale) {\u000a                    return locale;\u000a                }\u000a                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\u000a                    //the next array item is better than a shallower substring of this one\u000a                    break;\u000a                }\u000a                j--;\u000a            }\u000a            i++;\u000a        }\u000a        return null;\u000a    }\u000a\u000a    function loadLocale(name) {\u000a        var oldLocale = null;\u000a        // TODO: Find a better way to register and load all the locales in Node\u000a        if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {\u000a            try {\u000a                oldLocale = globalLocale._abbr;\u000a                require('./locale/' + name);\u000a                // because defineLocale currently also sets the global locale, we\u000a                // want to undo that for lazy loaded locales\u000a                locale_locales__getSetGlobalLocale(oldLocale);\u000a            } catch (e) {}\u000a        }\u000a        return locales[name];\u000a    }\u000a\u000a    // This function will load locale and then set the global locale.  If\u000a    // no arguments are passed in, it will simply return the current global\u000a    // locale key.\u000a    function locale_locales__getSetGlobalLocale(key, values) {\u000a        var data;\u000a        if (key) {\u000a            if (isUndefined(values)) {\u000a                data = locale_locales__getLocale(key);\u000a            } else {\u000a                data = defineLocale(key, values);\u000a            }\u000a\u000a            if (data) {\u000a                // moment.duration._locale = moment._locale = data;\u000a                globalLocale = data;\u000a            }\u000a        }\u000a\u000a        return globalLocale._abbr;\u000a    }\u000a\u000a    function defineLocale(name, config) {\u000a        if (config !== null) {\u000a            var parentConfig = baseConfig;\u000a            config.abbr = name;\u000a            if (locales[name] != null) {\u000a                deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\u000a                parentConfig = locales[name]._config;\u000a            } else if (config.parentLocale != null) {\u000a                if (locales[config.parentLocale] != null) {\u000a                    parentConfig = locales[config.parentLocale]._config;\u000a                } else {\u000a                    // treat as if there is no base config\u000a                    deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');\u000a                }\u000a            }\u000a            locales[name] = new Locale(mergeConfigs(parentConfig, config));\u000a\u000a            // backwards compat for now: also set the locale\u000a            locale_locales__getSetGlobalLocale(name);\u000a\u000a            return locales[name];\u000a        } else {\u000a            // useful for testing\u000a            delete locales[name];\u000a            return null;\u000a        }\u000a    }\u000a\u000a    function updateLocale(name, config) {\u000a        if (config != null) {\u000a            var locale,\u000a                parentConfig = baseConfig;\u000a            // MERGE\u000a            if (locales[name] != null) {\u000a                parentConfig = locales[name]._config;\u000a            }\u000a            config = mergeConfigs(parentConfig, config);\u000a            locale = new Locale(config);\u000a            locale.parentLocale = locales[name];\u000a            locales[name] = locale;\u000a\u000a            // backwards compat for now: also set the locale\u000a            locale_locales__getSetGlobalLocale(name);\u000a        } else {\u000a            // pass null for config to unupdate, useful for tests\u000a            if (locales[name] != null) {\u000a                if (locales[name].parentLocale != null) {\u000a                    locales[name] = locales[name].parentLocale;\u000a                } else if (locales[name] != null) {\u000a                    delete locales[name];\u000a                }\u000a            }\u000a        }\u000a        return locales[name];\u000a    }\u000a\u000a    // returns locale data\u000a    function locale_locales__getLocale(key) {\u000a        var locale;\u000a\u000a        if (key && key._locale && key._locale._abbr) {\u000a            key = key._locale._abbr;\u000a        }\u000a\u000a        if (!key) {\u000a            return globalLocale;\u000a        }\u000a\u000a        if (!isArray(key)) {\u000a            //short-circuit everything else\u000a            locale = loadLocale(key);\u000a            if (locale) {\u000a                return locale;\u000a            }\u000a            key = [key];\u000a        }\u000a\u000a        return chooseLocale(key);\u000a    }\u000a\u000a    function locale_locales__listLocales() {\u000a        return keys(locales);\u000a    }\u000a\u000a    function checkOverflow(m) {\u000a        var overflow;\u000a        var a = m._a;\u000a\u000a        if (a && getParsingFlags(m).overflow === -2) {\u000a            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\u000a\u000a            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\u000a                overflow = DATE;\u000a            }\u000a            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\u000a                overflow = WEEK;\u000a            }\u000a            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\u000a                overflow = WEEKDAY;\u000a            }\u000a\u000a            getParsingFlags(m).overflow = overflow;\u000a        }\u000a\u000a        return m;\u000a    }\u000a\u000a    // iso 8601 regex\u000a    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\u000a    var extendedIsoRegex = /^\u005cs*((?:[+-]\u005cd{6}|\u005cd{4})-(?:\u005cd\u005cd-\u005cd\u005cd|W\u005cd\u005cd-\u005cd|W\u005cd\u005cd|\u005cd\u005cd\u005cd|\u005cd\u005cd))(?:(T| )(\u005cd\u005cd(?::\u005cd\u005cd(?::\u005cd\u005cd(?:[.,]\u005cd+)?)?)?)([\u005c+\u005c-]\u005cd\u005cd(?::?\u005cd\u005cd)?|\u005cs*Z)?)?/;\u000a    var basicIsoRegex = /^\u005cs*((?:[+-]\u005cd{6}|\u005cd{4})(?:\u005cd\u005cd\u005cd\u005cd|W\u005cd\u005cd\u005cd|W\u005cd\u005cd|\u005cd\u005cd\u005cd|\u005cd\u005cd))(?:(T| )(\u005cd\u005cd(?:\u005cd\u005cd(?:\u005cd\u005cd(?:[.,]\u005cd+)?)?)?)([\u005c+\u005c-]\u005cd\u005cd(?::?\u005cd\u005cd)?|\u005cs*Z)?)?/;\u000a\u000a    var tzRegex = /Z|[+-]\u005cd\u005cd(?::?\u005cd\u005cd)?/;\u000a\u000a    var isoDates = [['YYYYYY-MM-DD', /[+-]\u005cd{6}-\u005cd\u005cd-\u005cd\u005cd/], ['YYYY-MM-DD', /\u005cd{4}-\u005cd\u005cd-\u005cd\u005cd/], ['GGGG-[W]WW-E', /\u005cd{4}-W\u005cd\u005cd-\u005cd/], ['GGGG-[W]WW', /\u005cd{4}-W\u005cd\u005cd/, false], ['YYYY-DDD', /\u005cd{4}-\u005cd{3}/], ['YYYY-MM', /\u005cd{4}-\u005cd\u005cd/, false], ['YYYYYYMMDD', /[+-]\u005cd{10}/], ['YYYYMMDD', /\u005cd{8}/],\u000a    // YYYYMM is NOT allowed by the standard\u000a    ['GGGG[W]WWE', /\u005cd{4}W\u005cd{3}/], ['GGGG[W]WW', /\u005cd{4}W\u005cd{2}/, false], ['YYYYDDD', /\u005cd{7}/]];\u000a\u000a    // iso time formats and regexes\u000a    var isoTimes = [['HH:mm:ss.SSSS', /\u005cd\u005cd:\u005cd\u005cd:\u005cd\u005cd\u005c.\u005cd+/], ['HH:mm:ss,SSSS', /\u005cd\u005cd:\u005cd\u005cd:\u005cd\u005cd,\u005cd+/], ['HH:mm:ss', /\u005cd\u005cd:\u005cd\u005cd:\u005cd\u005cd/], ['HH:mm', /\u005cd\u005cd:\u005cd\u005cd/], ['HHmmss.SSSS', /\u005cd\u005cd\u005cd\u005cd\u005cd\u005cd\u005c.\u005cd+/], ['HHmmss,SSSS', /\u005cd\u005cd\u005cd\u005cd\u005cd\u005cd,\u005cd+/], ['HHmmss', /\u005cd\u005cd\u005cd\u005cd\u005cd\u005cd/], ['HHmm', /\u005cd\u005cd\u005cd\u005cd/], ['HH', /\u005cd\u005cd/]];\u000a\u000a    var aspNetJsonRegex = /^\u005c/?Date\u005c((\u005c-?\u005cd+)/i;\u000a\u000a    // date from iso format\u000a    function configFromISO(config) {\u000a        var i,\u000a            l,\u000a            string = config._i,\u000a            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\u000a            allowTime,\u000a            dateFormat,\u000a            timeFormat,\u000a            tzFormat;\u000a\u000a        if (match) {\u000a            getParsingFlags(config).iso = true;\u000a\u000a            for (i = 0, l = isoDates.length; i < l; i++) {\u000a                if (isoDates[i][1].exec(match[1])) {\u000a                    dateFormat = isoDates[i][0];\u000a                    allowTime = isoDates[i][2] !== false;\u000a                    break;\u000a                }\u000a            }\u000a            if (dateFormat == null) {\u000a                config._isValid = false;\u000a                return;\u000a            }\u000a            if (match[3]) {\u000a                for (i = 0, l = isoTimes.length; i < l; i++) {\u000a                    if (isoTimes[i][1].exec(match[3])) {\u000a                        // match[2] should be 'T' or space\u000a                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\u000a                        break;\u000a                    }\u000a                }\u000a                if (timeFormat == null) {\u000a                    config._isValid = false;\u000a                    return;\u000a                }\u000a            }\u000a            if (!allowTime && timeFormat != null) {\u000a                config._isValid = false;\u000a                return;\u000a            }\u000a            if (match[4]) {\u000a                if (tzRegex.exec(match[4])) {\u000a                    tzFormat = 'Z';\u000a                } else {\u000a                    config._isValid = false;\u000a                    return;\u000a                }\u000a            }\u000a            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\u000a            configFromStringAndFormat(config);\u000a        } else {\u000a            config._isValid = false;\u000a        }\u000a    }\u000a\u000a    // date from iso format or fallback\u000a    function configFromString(config) {\u000a        var matched = aspNetJsonRegex.exec(config._i);\u000a\u000a        if (matched !== null) {\u000a            config._d = new Date(+matched[1]);\u000a            return;\u000a        }\u000a\u000a        configFromISO(config);\u000a        if (config._isValid === false) {\u000a            delete config._isValid;\u000a            utils_hooks__hooks.createFromInputFallback(config);\u000a        }\u000a    }\u000a\u000a    utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {\u000a        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\u000a    });\u000a\u000a    // Pick the first defined of two or three arguments.\u000a    function defaults(a, b, c) {\u000a        if (a != null) {\u000a            return a;\u000a        }\u000a        if (b != null) {\u000a            return b;\u000a        }\u000a        return c;\u000a    }\u000a\u000a    function currentDateArray(config) {\u000a        // hooks is actually the exported moment object\u000a        var nowValue = new Date(utils_hooks__hooks.now());\u000a        if (config._useUTC) {\u000a            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\u000a        }\u000a        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\u000a    }\u000a\u000a    // convert an array to a date.\u000a    // the array should mirror the parameters below\u000a    // note: all values past the year are optional and will default to the lowest possible value.\u000a    // [year, month, day , hour, minute, second, millisecond]\u000a    function configFromArray(config) {\u000a        var i,\u000a            date,\u000a            input = [],\u000a            currentDate,\u000a            yearToUse;\u000a\u000a        if (config._d) {\u000a            return;\u000a        }\u000a\u000a        currentDate = currentDateArray(config);\u000a\u000a        //compute day of the year from weeks and weekdays\u000a        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\u000a            dayOfYearFromWeekInfo(config);\u000a        }\u000a\u000a        //if the day of the year is set, figure out what it is\u000a        if (config._dayOfYear) {\u000a            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\u000a\u000a            if (config._dayOfYear > daysInYear(yearToUse)) {\u000a                getParsingFlags(config)._overflowDayOfYear = true;\u000a            }\u000a\u000a            date = createUTCDate(yearToUse, 0, config._dayOfYear);\u000a            config._a[MONTH] = date.getUTCMonth();\u000a            config._a[DATE] = date.getUTCDate();\u000a        }\u000a\u000a        // Default to current date.\u000a        // * if no year, month, day of month are given, default to today\u000a        // * if day of month is given, default month and year\u000a        // * if month is given, default only year\u000a        // * if year is given, don't default anything\u000a        for (i = 0; i < 3 && config._a[i] == null; ++i) {\u000a            config._a[i] = input[i] = currentDate[i];\u000a        }\u000a\u000a        // Zero out whatever was not defaulted, including time\u000a        for (; i < 7; i++) {\u000a            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\u000a        }\u000a\u000a        // Check for 24:00:00.000\u000a        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\u000a            config._nextDay = true;\u000a            config._a[HOUR] = 0;\u000a        }\u000a\u000a        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\u000a        // Apply timezone offset from input. The actual utcOffset can be changed\u000a        // with parseZone.\u000a        if (config._tzm != null) {\u000a            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\u000a        }\u000a\u000a        if (config._nextDay) {\u000a            config._a[HOUR] = 24;\u000a        }\u000a    }\u000a\u000a    function dayOfYearFromWeekInfo(config) {\u000a        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\u000a\u000a        w = config._w;\u000a        if (w.GG != null || w.W != null || w.E != null) {\u000a            dow = 1;\u000a            doy = 4;\u000a\u000a            // TODO: We need to take the current isoWeekYear, but that depends on\u000a            // how we interpret now (local, utc, fixed offset). So create\u000a            // a now version of current config (take local/utc/offset flags, and\u000a            // create now).\u000a            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);\u000a            week = defaults(w.W, 1);\u000a            weekday = defaults(w.E, 1);\u000a            if (weekday < 1 || weekday > 7) {\u000a                weekdayOverflow = true;\u000a            }\u000a        } else {\u000a            dow = config._locale._week.dow;\u000a            doy = config._locale._week.doy;\u000a\u000a            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);\u000a            week = defaults(w.w, 1);\u000a\u000a            if (w.d != null) {\u000a                // weekday -- low day numbers are considered next week\u000a                weekday = w.d;\u000a                if (weekday < 0 || weekday > 6) {\u000a                    weekdayOverflow = true;\u000a                }\u000a            } else if (w.e != null) {\u000a                // local weekday -- counting starts from begining of week\u000a                weekday = w.e + dow;\u000a                if (w.e < 0 || w.e > 6) {\u000a                    weekdayOverflow = true;\u000a                }\u000a            } else {\u000a                // default to begining of week\u000a                weekday = dow;\u000a            }\u000a        }\u000a        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\u000a            getParsingFlags(config)._overflowWeeks = true;\u000a        } else if (weekdayOverflow != null) {\u000a            getParsingFlags(config)._overflowWeekday = true;\u000a        } else {\u000a            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\u000a            config._a[YEAR] = temp.year;\u000a            config._dayOfYear = temp.dayOfYear;\u000a        }\u000a    }\u000a\u000a    // constant that refers to the ISO standard\u000a    utils_hooks__hooks.ISO_8601 = function () {};\u000a\u000a    // date from string and format string\u000a    function configFromStringAndFormat(config) {\u000a        // TODO: Move this to another part of the creation flow to prevent circular deps\u000a        if (config._f === utils_hooks__hooks.ISO_8601) {\u000a            configFromISO(config);\u000a            return;\u000a        }\u000a\u000a        config._a = [];\u000a        getParsingFlags(config).empty = true;\u000a\u000a        // This array is used to make a Date, either with `new Date` or `Date.UTC`\u000a        var string = '' + config._i,\u000a            i,\u000a            parsedInput,\u000a            tokens,\u000a            token,\u000a            skipped,\u000a            stringLength = string.length,\u000a            totalParsedInputLength = 0;\u000a\u000a        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\u000a\u000a        for (i = 0; i < tokens.length; i++) {\u000a            token = tokens[i];\u000a            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\u000a            // console.log('token', token, 'parsedInput', parsedInput,\u000a            //         'regex', getParseRegexForToken(token, config));\u000a            if (parsedInput) {\u000a                skipped = string.substr(0, string.indexOf(parsedInput));\u000a                if (skipped.length > 0) {\u000a                    getParsingFlags(config).unusedInput.push(skipped);\u000a                }\u000a                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\u000a                totalParsedInputLength += parsedInput.length;\u000a            }\u000a            // don't parse if it's not a known token\u000a            if (formatTokenFunctions[token]) {\u000a                if (parsedInput) {\u000a                    getParsingFlags(config).empty = false;\u000a                } else {\u000a                    getParsingFlags(config).unusedTokens.push(token);\u000a                }\u000a                addTimeToArrayFromToken(token, parsedInput, config);\u000a            } else if (config._strict && !parsedInput) {\u000a                getParsingFlags(config).unusedTokens.push(token);\u000a            }\u000a        }\u000a\u000a        // add remaining unparsed input length to the string\u000a        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\u000a        if (string.length > 0) {\u000a            getParsingFlags(config).unusedInput.push(string);\u000a        }\u000a\u000a        // clear _12h flag if hour is <= 12\u000a        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\u000a            getParsingFlags(config).bigHour = undefined;\u000a        }\u000a\u000a        getParsingFlags(config).parsedDateParts = config._a.slice(0);\u000a        getParsingFlags(config).meridiem = config._meridiem;\u000a        // handle meridiem\u000a        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\u000a\u000a        configFromArray(config);\u000a        checkOverflow(config);\u000a    }\u000a\u000a    function meridiemFixWrap(locale, hour, meridiem) {\u000a        var isPm;\u000a\u000a        if (meridiem == null) {\u000a            // nothing to do\u000a            return hour;\u000a        }\u000a        if (locale.meridiemHour != null) {\u000a            return locale.meridiemHour(hour, meridiem);\u000a        } else if (locale.isPM != null) {\u000a            // Fallback\u000a            isPm = locale.isPM(meridiem);\u000a            if (isPm && hour < 12) {\u000a                hour += 12;\u000a            }\u000a            if (!isPm && hour === 12) {\u000a                hour = 0;\u000a            }\u000a            return hour;\u000a        } else {\u000a            // this is not supposed to happen\u000a            return hour;\u000a        }\u000a    }\u000a\u000a    // date from string and array of format strings\u000a    function configFromStringAndArray(config) {\u000a        var tempConfig, bestMoment, scoreToBeat, i, currentScore;\u000a\u000a        if (config._f.length === 0) {\u000a            getParsingFlags(config).invalidFormat = true;\u000a            config._d = new Date(NaN);\u000a            return;\u000a        }\u000a\u000a        for (i = 0; i < config._f.length; i++) {\u000a            currentScore = 0;\u000a            tempConfig = copyConfig({}, config);\u000a            if (config._useUTC != null) {\u000a                tempConfig._useUTC = config._useUTC;\u000a            }\u000a            tempConfig._f = config._f[i];\u000a            configFromStringAndFormat(tempConfig);\u000a\u000a            if (!valid__isValid(tempConfig)) {\u000a                continue;\u000a            }\u000a\u000a            // if there is any input that was not parsed add a penalty for that format\u000a            currentScore += getParsingFlags(tempConfig).charsLeftOver;\u000a\u000a            //or tokens\u000a            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\u000a\u000a            getParsingFlags(tempConfig).score = currentScore;\u000a\u000a            if (scoreToBeat == null || currentScore < scoreToBeat) {\u000a                scoreToBeat = currentScore;\u000a                bestMoment = tempConfig;\u000a            }\u000a        }\u000a\u000a        extend(config, bestMoment || tempConfig);\u000a    }\u000a\u000a    function configFromObject(config) {\u000a        if (config._d) {\u000a            return;\u000a        }\u000a\u000a        var i = normalizeObjectUnits(config._i);\u000a        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\u000a            return obj && parseInt(obj, 10);\u000a        });\u000a\u000a        configFromArray(config);\u000a    }\u000a\u000a    function createFromConfig(config) {\u000a        var res = new Moment(checkOverflow(prepareConfig(config)));\u000a        if (res._nextDay) {\u000a            // Adding is smart enough around DST\u000a            res.add(1, 'd');\u000a            res._nextDay = undefined;\u000a        }\u000a\u000a        return res;\u000a    }\u000a\u000a    function prepareConfig(config) {\u000a        var input = config._i,\u000a            format = config._f;\u000a\u000a        config._locale = config._locale || locale_locales__getLocale(config._l);\u000a\u000a        if (input === null || format === undefined && input === '') {\u000a            return valid__createInvalid({ nullInput: true });\u000a        }\u000a\u000a        if (typeof input === 'string') {\u000a            config._i = input = config._locale.preparse(input);\u000a        }\u000a\u000a        if (isMoment(input)) {\u000a            return new Moment(checkOverflow(input));\u000a        } else if (isArray(format)) {\u000a            configFromStringAndArray(config);\u000a        } else if (isDate(input)) {\u000a            config._d = input;\u000a        } else if (format) {\u000a            configFromStringAndFormat(config);\u000a        } else {\u000a            configFromInput(config);\u000a        }\u000a\u000a        if (!valid__isValid(config)) {\u000a            config._d = null;\u000a        }\u000a\u000a        return config;\u000a    }\u000a\u000a    function configFromInput(config) {\u000a        var input = config._i;\u000a        if (input === undefined) {\u000a            config._d = new Date(utils_hooks__hooks.now());\u000a        } else if (isDate(input)) {\u000a            config._d = new Date(input.valueOf());\u000a        } else if (typeof input === 'string') {\u000a            configFromString(config);\u000a        } else if (isArray(input)) {\u000a            config._a = map(input.slice(0), function (obj) {\u000a                return parseInt(obj, 10);\u000a            });\u000a            configFromArray(config);\u000a        } else if (typeof input === 'object') {\u000a            configFromObject(config);\u000a        } else if (typeof input === 'number') {\u000a            // from milliseconds\u000a            config._d = new Date(input);\u000a        } else {\u000a            utils_hooks__hooks.createFromInputFallback(config);\u000a        }\u000a    }\u000a\u000a    function createLocalOrUTC(input, format, locale, strict, isUTC) {\u000a        var c = {};\u000a\u000a        if (typeof locale === 'boolean') {\u000a            strict = locale;\u000a            locale = undefined;\u000a        }\u000a\u000a        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\u000a            input = undefined;\u000a        }\u000a        // object construction must be done this way.\u000a        // https://github.com/moment/moment/issues/1423\u000a        c._isAMomentObject = true;\u000a        c._useUTC = c._isUTC = isUTC;\u000a        c._l = locale;\u000a        c._i = input;\u000a        c._f = format;\u000a        c._strict = strict;\u000a\u000a        return createFromConfig(c);\u000a    }\u000a\u000a    function local__createLocal(input, format, locale, strict) {\u000a        return createLocalOrUTC(input, format, locale, strict, false);\u000a    }\u000a\u000a    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\u000a        var other = local__createLocal.apply(null, arguments);\u000a        if (this.isValid() && other.isValid()) {\u000a            return other < this ? this : other;\u000a        } else {\u000a            return valid__createInvalid();\u000a        }\u000a    });\u000a\u000a    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\u000a        var other = local__createLocal.apply(null, arguments);\u000a        if (this.isValid() && other.isValid()) {\u000a            return other > this ? this : other;\u000a        } else {\u000a            return valid__createInvalid();\u000a        }\u000a    });\u000a\u000a    // Pick a moment m from moments so that m[fn](other) is true for all\u000a    // other. This relies on the function fn to be transitive.\u000a    //\u000a    // moments should either be an array of moment objects or an array, whose\u000a    // first element is an array of moment objects.\u000a    function pickBy(fn, moments) {\u000a        var res, i;\u000a        if (moments.length === 1 && isArray(moments[0])) {\u000a            moments = moments[0];\u000a        }\u000a        if (!moments.length) {\u000a            return local__createLocal();\u000a        }\u000a        res = moments[0];\u000a        for (i = 1; i < moments.length; ++i) {\u000a            if (!moments[i].isValid() || moments[i][fn](res)) {\u000a                res = moments[i];\u000a            }\u000a        }\u000a        return res;\u000a    }\u000a\u000a    // TODO: Use [].sort instead?\u000a    function min() {\u000a        var args = [].slice.call(arguments, 0);\u000a\u000a        return pickBy('isBefore', args);\u000a    }\u000a\u000a    function max() {\u000a        var args = [].slice.call(arguments, 0);\u000a\u000a        return pickBy('isAfter', args);\u000a    }\u000a\u000a    var now = function () {\u000a        return Date.now ? Date.now() : +new Date();\u000a    };\u000a\u000a    function Duration(duration) {\u000a        var normalizedInput = normalizeObjectUnits(duration),\u000a            years = normalizedInput.year || 0,\u000a            quarters = normalizedInput.quarter || 0,\u000a            months = normalizedInput.month || 0,\u000a            weeks = normalizedInput.week || 0,\u000a            days = normalizedInput.day || 0,\u000a            hours = normalizedInput.hour || 0,\u000a            minutes = normalizedInput.minute || 0,\u000a            seconds = normalizedInput.second || 0,\u000a            milliseconds = normalizedInput.millisecond || 0;\u000a\u000a        // representation for dateAddRemove\u000a        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\u000a        minutes * 6e4 + // 1000 * 60\u000a        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\u000a        // Because of dateAddRemove treats 24 hours as different from a\u000a        // day when working around DST, we need to store them separately\u000a        this._days = +days + weeks * 7;\u000a        // It is impossible translate months into days without knowing\u000a        // which months you are are talking about, so we have to store\u000a        // it separately.\u000a        this._months = +months + quarters * 3 + years * 12;\u000a\u000a        this._data = {};\u000a\u000a        this._locale = locale_locales__getLocale();\u000a\u000a        this._bubble();\u000a    }\u000a\u000a    function isDuration(obj) {\u000a        return obj instanceof Duration;\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    function offset(token, separator) {\u000a        addFormatToken(token, 0, 0, function () {\u000a            var offset = this.utcOffset();\u000a            var sign = '+';\u000a            if (offset < 0) {\u000a                offset = -offset;\u000a                sign = '-';\u000a            }\u000a            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\u000a        });\u000a    }\u000a\u000a    offset('Z', ':');\u000a    offset('ZZ', '');\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('Z', matchShortOffset);\u000a    addRegexToken('ZZ', matchShortOffset);\u000a    addParseToken(['Z', 'ZZ'], function (input, array, config) {\u000a        config._useUTC = true;\u000a        config._tzm = offsetFromString(matchShortOffset, input);\u000a    });\u000a\u000a    // HELPERS\u000a\u000a    // timezone chunker\u000a    // '+10:00' > ['10',  '00']\u000a    // '-1530'  > ['-15', '30']\u000a    var chunkOffset = /([\u005c+\u005c-]|\u005cd\u005cd)/gi;\u000a\u000a    function offsetFromString(matcher, string) {\u000a        var matches = (string || '').match(matcher) || [];\u000a        var chunk = matches[matches.length - 1] || [];\u000a        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\u000a        var minutes = +(parts[1] * 60) + toInt(parts[2]);\u000a\u000a        return parts[0] === '+' ? minutes : -minutes;\u000a    }\u000a\u000a    // Return a moment from input, that is local/utc/zone equivalent to model.\u000a    function cloneWithOffset(input, model) {\u000a        var res, diff;\u000a        if (model._isUTC) {\u000a            res = model.clone();\u000a            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();\u000a            // Use low-level api, because this fn is low-level api.\u000a            res._d.setTime(res._d.valueOf() + diff);\u000a            utils_hooks__hooks.updateOffset(res, false);\u000a            return res;\u000a        } else {\u000a            return local__createLocal(input).local();\u000a        }\u000a    }\u000a\u000a    function getDateOffset(m) {\u000a        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\u000a        // https://github.com/moment/moment/pull/1871\u000a        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\u000a    }\u000a\u000a    // HOOKS\u000a\u000a    // This function will be called whenever a moment is mutated.\u000a    // It is intended to keep the offset in sync with the timezone.\u000a    utils_hooks__hooks.updateOffset = function () {};\u000a\u000a    // MOMENTS\u000a\u000a    // keepLocalTime = true means only change the timezone, without\u000a    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\u000a    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\u000a    // +0200, so we adjust the time as needed, to be valid.\u000a    //\u000a    // Keeping the time actually adds/subtracts (one hour)\u000a    // from the actual represented time. That is why we call updateOffset\u000a    // a second time. In case it wants us to change the offset again\u000a    // _changeInProgress == true case, then we have to adjust, because\u000a    // there is no such time in the given timezone.\u000a    function getSetOffset(input, keepLocalTime) {\u000a        var offset = this._offset || 0,\u000a            localAdjust;\u000a        if (!this.isValid()) {\u000a            return input != null ? this : NaN;\u000a        }\u000a        if (input != null) {\u000a            if (typeof input === 'string') {\u000a                input = offsetFromString(matchShortOffset, input);\u000a            } else if (Math.abs(input) < 16) {\u000a                input = input * 60;\u000a            }\u000a            if (!this._isUTC && keepLocalTime) {\u000a                localAdjust = getDateOffset(this);\u000a            }\u000a            this._offset = input;\u000a            this._isUTC = true;\u000a            if (localAdjust != null) {\u000a                this.add(localAdjust, 'm');\u000a            }\u000a            if (offset !== input) {\u000a                if (!keepLocalTime || this._changeInProgress) {\u000a                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);\u000a                } else if (!this._changeInProgress) {\u000a                    this._changeInProgress = true;\u000a                    utils_hooks__hooks.updateOffset(this, true);\u000a                    this._changeInProgress = null;\u000a                }\u000a            }\u000a            return this;\u000a        } else {\u000a            return this._isUTC ? offset : getDateOffset(this);\u000a        }\u000a    }\u000a\u000a    function getSetZone(input, keepLocalTime) {\u000a        if (input != null) {\u000a            if (typeof input !== 'string') {\u000a                input = -input;\u000a            }\u000a\u000a            this.utcOffset(input, keepLocalTime);\u000a\u000a            return this;\u000a        } else {\u000a            return -this.utcOffset();\u000a        }\u000a    }\u000a\u000a    function setOffsetToUTC(keepLocalTime) {\u000a        return this.utcOffset(0, keepLocalTime);\u000a    }\u000a\u000a    function setOffsetToLocal(keepLocalTime) {\u000a        if (this._isUTC) {\u000a            this.utcOffset(0, keepLocalTime);\u000a            this._isUTC = false;\u000a\u000a            if (keepLocalTime) {\u000a                this.subtract(getDateOffset(this), 'm');\u000a            }\u000a        }\u000a        return this;\u000a    }\u000a\u000a    function setOffsetToParsedOffset() {\u000a        if (this._tzm) {\u000a            this.utcOffset(this._tzm);\u000a        } else if (typeof this._i === 'string') {\u000a            this.utcOffset(offsetFromString(matchOffset, this._i));\u000a        }\u000a        return this;\u000a    }\u000a\u000a    function hasAlignedHourOffset(input) {\u000a        if (!this.isValid()) {\u000a            return false;\u000a        }\u000a        input = input ? local__createLocal(input).utcOffset() : 0;\u000a\u000a        return (this.utcOffset() - input) % 60 === 0;\u000a    }\u000a\u000a    function isDaylightSavingTime() {\u000a        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\u000a    }\u000a\u000a    function isDaylightSavingTimeShifted() {\u000a        if (!isUndefined(this._isDSTShifted)) {\u000a            return this._isDSTShifted;\u000a        }\u000a\u000a        var c = {};\u000a\u000a        copyConfig(c, this);\u000a        c = prepareConfig(c);\u000a\u000a        if (c._a) {\u000a            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);\u000a            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\u000a        } else {\u000a            this._isDSTShifted = false;\u000a        }\u000a\u000a        return this._isDSTShifted;\u000a    }\u000a\u000a    function isLocal() {\u000a        return this.isValid() ? !this._isUTC : false;\u000a    }\u000a\u000a    function isUtcOffset() {\u000a        return this.isValid() ? this._isUTC : false;\u000a    }\u000a\u000a    function isUtc() {\u000a        return this.isValid() ? this._isUTC && this._offset === 0 : false;\u000a    }\u000a\u000a    // ASP.NET json date format regex\u000a    var aspNetRegex = /^(\u005c-)?(?:(\u005cd*)[. ])?(\u005cd+)\u005c:(\u005cd+)(?:\u005c:(\u005cd+)\u005c.?(\u005cd{3})?\u005cd*)?$/;\u000a\u000a    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\u000a    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\u000a    // and further modified to allow for strings containing both week and day\u000a    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\u000a\u000a    function create__createDuration(input, key) {\u000a        var duration = input,\u000a\u000a        // matching against regexp is expensive, do it on demand\u000a        match = null,\u000a            sign,\u000a            ret,\u000a            diffRes;\u000a\u000a        if (isDuration(input)) {\u000a            duration = {\u000a                ms: input._milliseconds,\u000a                d: input._days,\u000a                M: input._months\u000a            };\u000a        } else if (typeof input === 'number') {\u000a            duration = {};\u000a            if (key) {\u000a                duration[key] = input;\u000a            } else {\u000a                duration.milliseconds = input;\u000a            }\u000a        } else if (!!(match = aspNetRegex.exec(input))) {\u000a            sign = match[1] === '-' ? -1 : 1;\u000a            duration = {\u000a                y: 0,\u000a                d: toInt(match[DATE]) * sign,\u000a                h: toInt(match[HOUR]) * sign,\u000a                m: toInt(match[MINUTE]) * sign,\u000a                s: toInt(match[SECOND]) * sign,\u000a                ms: toInt(match[MILLISECOND]) * sign\u000a            };\u000a        } else if (!!(match = isoRegex.exec(input))) {\u000a            sign = match[1] === '-' ? -1 : 1;\u000a            duration = {\u000a                y: parseIso(match[2], sign),\u000a                M: parseIso(match[3], sign),\u000a                w: parseIso(match[4], sign),\u000a                d: parseIso(match[5], sign),\u000a                h: parseIso(match[6], sign),\u000a                m: parseIso(match[7], sign),\u000a                s: parseIso(match[8], sign)\u000a            };\u000a        } else if (duration == null) {\u000a            // checks for null or undefined\u000a            duration = {};\u000a        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\u000a            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));\u000a\u000a            duration = {};\u000a            duration.ms = diffRes.milliseconds;\u000a            duration.M = diffRes.months;\u000a        }\u000a\u000a        ret = new Duration(duration);\u000a\u000a        if (isDuration(input) && hasOwnProp(input, '_locale')) {\u000a            ret._locale = input._locale;\u000a        }\u000a\u000a        return ret;\u000a    }\u000a\u000a    create__createDuration.fn = Duration.prototype;\u000a\u000a    function parseIso(inp, sign) {\u000a        // We'd normally use ~~inp for this, but unfortunately it also\u000a        // converts floats to ints.\u000a        // inp may be undefined, so careful calling replace on it.\u000a        var res = inp && parseFloat(inp.replace(',', '.'));\u000a        // apply sign while we're at it\u000a        return (isNaN(res) ? 0 : res) * sign;\u000a    }\u000a\u000a    function positiveMomentsDifference(base, other) {\u000a        var res = { milliseconds: 0, months: 0 };\u000a\u000a        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\u000a        if (base.clone().add(res.months, 'M').isAfter(other)) {\u000a            --res.months;\u000a        }\u000a\u000a        res.milliseconds = +other - +base.clone().add(res.months, 'M');\u000a\u000a        return res;\u000a    }\u000a\u000a    function momentsDifference(base, other) {\u000a        var res;\u000a        if (!(base.isValid() && other.isValid())) {\u000a            return { milliseconds: 0, months: 0 };\u000a        }\u000a\u000a        other = cloneWithOffset(other, base);\u000a        if (base.isBefore(other)) {\u000a            res = positiveMomentsDifference(base, other);\u000a        } else {\u000a            res = positiveMomentsDifference(other, base);\u000a            res.milliseconds = -res.milliseconds;\u000a            res.months = -res.months;\u000a        }\u000a\u000a        return res;\u000a    }\u000a\u000a    function absRound(number) {\u000a        if (number < 0) {\u000a            return Math.round(-1 * number) * -1;\u000a        } else {\u000a            return Math.round(number);\u000a        }\u000a    }\u000a\u000a    // TODO: remove 'name' arg after deprecation is removed\u000a    function createAdder(direction, name) {\u000a        return function (val, period) {\u000a            var dur, tmp;\u000a            //invert the arguments, but complain about it\u000a            if (period !== null && !isNaN(+period)) {\u000a                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\u000a                tmp = val;val = period;period = tmp;\u000a            }\u000a\u000a            val = typeof val === 'string' ? +val : val;\u000a            dur = create__createDuration(val, period);\u000a            add_subtract__addSubtract(this, dur, direction);\u000a            return this;\u000a        };\u000a    }\u000a\u000a    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {\u000a        var milliseconds = duration._milliseconds,\u000a            days = absRound(duration._days),\u000a            months = absRound(duration._months);\u000a\u000a        if (!mom.isValid()) {\u000a            // No op\u000a            return;\u000a        }\u000a\u000a        updateOffset = updateOffset == null ? true : updateOffset;\u000a\u000a        if (milliseconds) {\u000a            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\u000a        }\u000a        if (days) {\u000a            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);\u000a        }\u000a        if (months) {\u000a            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);\u000a        }\u000a        if (updateOffset) {\u000a            utils_hooks__hooks.updateOffset(mom, days || months);\u000a        }\u000a    }\u000a\u000a    var add_subtract__add = createAdder(1, 'add');\u000a    var add_subtract__subtract = createAdder(-1, 'subtract');\u000a\u000a    function getCalendarFormat(myMoment, now) {\u000a        var diff = myMoment.diff(now, 'days', true);\u000a        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';\u000a    }\u000a\u000a    function moment_calendar__calendar(time, formats) {\u000a        // We want to compare the start of today, vs this.\u000a        // Getting start-of-today depends on whether we're local/utc/offset or not.\u000a        var now = time || local__createLocal(),\u000a            sod = cloneWithOffset(now, this).startOf('day'),\u000a            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';\u000a\u000a        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\u000a\u000a        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));\u000a    }\u000a\u000a    function clone() {\u000a        return new Moment(this);\u000a    }\u000a\u000a    function isAfter(input, units) {\u000a        var localInput = isMoment(input) ? input : local__createLocal(input);\u000a        if (!(this.isValid() && localInput.isValid())) {\u000a            return false;\u000a        }\u000a        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\u000a        if (units === 'millisecond') {\u000a            return this.valueOf() > localInput.valueOf();\u000a        } else {\u000a            return localInput.valueOf() < this.clone().startOf(units).valueOf();\u000a        }\u000a    }\u000a\u000a    function isBefore(input, units) {\u000a        var localInput = isMoment(input) ? input : local__createLocal(input);\u000a        if (!(this.isValid() && localInput.isValid())) {\u000a            return false;\u000a        }\u000a        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\u000a        if (units === 'millisecond') {\u000a            return this.valueOf() < localInput.valueOf();\u000a        } else {\u000a            return this.clone().endOf(units).valueOf() < localInput.valueOf();\u000a        }\u000a    }\u000a\u000a    function isBetween(from, to, units, inclusivity) {\u000a        inclusivity = inclusivity || '()';\u000a        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\u000a    }\u000a\u000a    function isSame(input, units) {\u000a        var localInput = isMoment(input) ? input : local__createLocal(input),\u000a            inputMs;\u000a        if (!(this.isValid() && localInput.isValid())) {\u000a            return false;\u000a        }\u000a        units = normalizeUnits(units || 'millisecond');\u000a        if (units === 'millisecond') {\u000a            return this.valueOf() === localInput.valueOf();\u000a        } else {\u000a            inputMs = localInput.valueOf();\u000a            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\u000a        }\u000a    }\u000a\u000a    function isSameOrAfter(input, units) {\u000a        return this.isSame(input, units) || this.isAfter(input, units);\u000a    }\u000a\u000a    function isSameOrBefore(input, units) {\u000a        return this.isSame(input, units) || this.isBefore(input, units);\u000a    }\u000a\u000a    function diff(input, units, asFloat) {\u000a        var that, zoneDelta, delta, output;\u000a\u000a        if (!this.isValid()) {\u000a            return NaN;\u000a        }\u000a\u000a        that = cloneWithOffset(input, this);\u000a\u000a        if (!that.isValid()) {\u000a            return NaN;\u000a        }\u000a\u000a        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\u000a\u000a        units = normalizeUnits(units);\u000a\u000a        if (units === 'year' || units === 'month' || units === 'quarter') {\u000a            output = monthDiff(this, that);\u000a            if (units === 'quarter') {\u000a                output = output / 3;\u000a            } else if (units === 'year') {\u000a                output = output / 12;\u000a            }\u000a        } else {\u000a            delta = this - that;\u000a            output = units === 'second' ? delta / 1e3 : // 1000\u000a            units === 'minute' ? delta / 6e4 : // 1000 * 60\u000a            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\u000a            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\u000a            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\u000a            delta;\u000a        }\u000a        return asFloat ? output : absFloor(output);\u000a    }\u000a\u000a    function monthDiff(a, b) {\u000a        // difference in months\u000a        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\u000a\u000a        // b is in (anchor - 1 month, anchor + 1 month)\u000a        anchor = a.clone().add(wholeMonthDiff, 'months'),\u000a            anchor2,\u000a            adjust;\u000a\u000a        if (b - anchor < 0) {\u000a            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\u000a            // linear across the month\u000a            adjust = (b - anchor) / (anchor - anchor2);\u000a        } else {\u000a            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\u000a            // linear across the month\u000a            adjust = (b - anchor) / (anchor2 - anchor);\u000a        }\u000a\u000a        //check for negative zero, return zero if negative zero\u000a        return -(wholeMonthDiff + adjust) || 0;\u000a    }\u000a\u000a    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\u000a    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\u000a\u000a    function toString() {\u000a        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\u000a    }\u000a\u000a    function moment_format__toISOString() {\u000a        var m = this.clone().utc();\u000a        if (0 < m.year() && m.year() <= 9999) {\u000a            if (isFunction(Date.prototype.toISOString)) {\u000a                // native implementation is ~50x faster, use it when we can\u000a                return this.toDate().toISOString();\u000a            } else {\u000a                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\u000a            }\u000a        } else {\u000a            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\u000a        }\u000a    }\u000a\u000a    function format(inputString) {\u000a        if (!inputString) {\u000a            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;\u000a        }\u000a        var output = formatMoment(this, inputString);\u000a        return this.localeData().postformat(output);\u000a    }\u000a\u000a    function from(time, withoutSuffix) {\u000a        if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {\u000a            return create__createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);\u000a        } else {\u000a            return this.localeData().invalidDate();\u000a        }\u000a    }\u000a\u000a    function fromNow(withoutSuffix) {\u000a        return this.from(local__createLocal(), withoutSuffix);\u000a    }\u000a\u000a    function to(time, withoutSuffix) {\u000a        if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {\u000a            return create__createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);\u000a        } else {\u000a            return this.localeData().invalidDate();\u000a        }\u000a    }\u000a\u000a    function toNow(withoutSuffix) {\u000a        return this.to(local__createLocal(), withoutSuffix);\u000a    }\u000a\u000a    // If passed a locale key, it will set the locale for this\u000a    // instance.  Otherwise, it will return the locale configuration\u000a    // variables for this instance.\u000a    function locale(key) {\u000a        var newLocaleData;\u000a\u000a        if (key === undefined) {\u000a            return this._locale._abbr;\u000a        } else {\u000a            newLocaleData = locale_locales__getLocale(key);\u000a            if (newLocaleData != null) {\u000a                this._locale = newLocaleData;\u000a            }\u000a            return this;\u000a        }\u000a    }\u000a\u000a    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {\u000a        if (key === undefined) {\u000a            return this.localeData();\u000a        } else {\u000a            return this.locale(key);\u000a        }\u000a    });\u000a\u000a    function localeData() {\u000a        return this._locale;\u000a    }\u000a\u000a    function startOf(units) {\u000a        units = normalizeUnits(units);\u000a        // the following switch intentionally omits break keywords\u000a        // to utilize falling through the cases.\u000a        switch (units) {\u000a            case 'year':\u000a                this.month(0);\u000a            /* falls through */\u000a            case 'quarter':\u000a            case 'month':\u000a                this.date(1);\u000a            /* falls through */\u000a            case 'week':\u000a            case 'isoWeek':\u000a            case 'day':\u000a            case 'date':\u000a                this.hours(0);\u000a            /* falls through */\u000a            case 'hour':\u000a                this.minutes(0);\u000a            /* falls through */\u000a            case 'minute':\u000a                this.seconds(0);\u000a            /* falls through */\u000a            case 'second':\u000a                this.milliseconds(0);\u000a        }\u000a\u000a        // weeks are a special case\u000a        if (units === 'week') {\u000a            this.weekday(0);\u000a        }\u000a        if (units === 'isoWeek') {\u000a            this.isoWeekday(1);\u000a        }\u000a\u000a        // quarters are also special\u000a        if (units === 'quarter') {\u000a            this.month(Math.floor(this.month() / 3) * 3);\u000a        }\u000a\u000a        return this;\u000a    }\u000a\u000a    function endOf(units) {\u000a        units = normalizeUnits(units);\u000a        if (units === undefined || units === 'millisecond') {\u000a            return this;\u000a        }\u000a\u000a        // 'date' is an alias for 'day', so it should be considered as such.\u000a        if (units === 'date') {\u000a            units = 'day';\u000a        }\u000a\u000a        return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');\u000a    }\u000a\u000a    function to_type__valueOf() {\u000a        return this._d.valueOf() - (this._offset || 0) * 60000;\u000a    }\u000a\u000a    function unix() {\u000a        return Math.floor(this.valueOf() / 1000);\u000a    }\u000a\u000a    function toDate() {\u000a        return new Date(this.valueOf());\u000a    }\u000a\u000a    function toArray() {\u000a        var m = this;\u000a        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\u000a    }\u000a\u000a    function toObject() {\u000a        var m = this;\u000a        return {\u000a            years: m.year(),\u000a            months: m.month(),\u000a            date: m.date(),\u000a            hours: m.hours(),\u000a            minutes: m.minutes(),\u000a            seconds: m.seconds(),\u000a            milliseconds: m.milliseconds()\u000a        };\u000a    }\u000a\u000a    function toJSON() {\u000a        // new Date(NaN).toJSON() === null\u000a        return this.isValid() ? this.toISOString() : null;\u000a    }\u000a\u000a    function moment_valid__isValid() {\u000a        return valid__isValid(this);\u000a    }\u000a\u000a    function parsingFlags() {\u000a        return extend({}, getParsingFlags(this));\u000a    }\u000a\u000a    function invalidAt() {\u000a        return getParsingFlags(this).overflow;\u000a    }\u000a\u000a    function creationData() {\u000a        return {\u000a            input: this._i,\u000a            format: this._f,\u000a            locale: this._locale,\u000a            isUTC: this._isUTC,\u000a            strict: this._strict\u000a        };\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken(0, ['gg', 2], 0, function () {\u000a        return this.weekYear() % 100;\u000a    });\u000a\u000a    addFormatToken(0, ['GG', 2], 0, function () {\u000a        return this.isoWeekYear() % 100;\u000a    });\u000a\u000a    function addWeekYearFormatToken(token, getter) {\u000a        addFormatToken(0, [token, token.length], 0, getter);\u000a    }\u000a\u000a    addWeekYearFormatToken('gggg', 'weekYear');\u000a    addWeekYearFormatToken('ggggg', 'weekYear');\u000a    addWeekYearFormatToken('GGGG', 'isoWeekYear');\u000a    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('weekYear', 'gg');\u000a    addUnitAlias('isoWeekYear', 'GG');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('weekYear', 1);\u000a    addUnitPriority('isoWeekYear', 1);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('G', matchSigned);\u000a    addRegexToken('g', matchSigned);\u000a    addRegexToken('GG', match1to2, match2);\u000a    addRegexToken('gg', match1to2, match2);\u000a    addRegexToken('GGGG', match1to4, match4);\u000a    addRegexToken('gggg', match1to4, match4);\u000a    addRegexToken('GGGGG', match1to6, match6);\u000a    addRegexToken('ggggg', match1to6, match6);\u000a\u000a    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\u000a        week[token.substr(0, 2)] = toInt(input);\u000a    });\u000a\u000a    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\u000a        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);\u000a    });\u000a\u000a    // MOMENTS\u000a\u000a    function getSetWeekYear(input) {\u000a        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\u000a    }\u000a\u000a    function getSetISOWeekYear(input) {\u000a        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\u000a    }\u000a\u000a    function getISOWeeksInYear() {\u000a        return weeksInYear(this.year(), 1, 4);\u000a    }\u000a\u000a    function getWeeksInYear() {\u000a        var weekInfo = this.localeData()._week;\u000a        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\u000a    }\u000a\u000a    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\u000a        var weeksTarget;\u000a        if (input == null) {\u000a            return weekOfYear(this, dow, doy).year;\u000a        } else {\u000a            weeksTarget = weeksInYear(input, dow, doy);\u000a            if (week > weeksTarget) {\u000a                week = weeksTarget;\u000a            }\u000a            return setWeekAll.call(this, input, week, weekday, dow, doy);\u000a        }\u000a    }\u000a\u000a    function setWeekAll(weekYear, week, weekday, dow, doy) {\u000a        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\u000a            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\u000a\u000a        this.year(date.getUTCFullYear());\u000a        this.month(date.getUTCMonth());\u000a        this.date(date.getUTCDate());\u000a        return this;\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('Q', 0, 'Qo', 'quarter');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('quarter', 'Q');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('quarter', 7);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('Q', match1);\u000a    addParseToken('Q', function (input, array) {\u000a        array[MONTH] = (toInt(input) - 1) * 3;\u000a    });\u000a\u000a    // MOMENTS\u000a\u000a    function getSetQuarter(input) {\u000a        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('D', ['DD', 2], 'Do', 'date');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('date', 'D');\u000a\u000a    // PRIOROITY\u000a    addUnitPriority('date', 9);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('D', match1to2);\u000a    addRegexToken('DD', match1to2, match2);\u000a    addRegexToken('Do', function (isStrict, locale) {\u000a        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\u000a    });\u000a\u000a    addParseToken(['D', 'DD'], DATE);\u000a    addParseToken('Do', function (input, array) {\u000a        array[DATE] = toInt(input.match(match1to2)[0], 10);\u000a    });\u000a\u000a    // MOMENTS\u000a\u000a    var getSetDayOfMonth = makeGetSet('Date', true);\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('dayOfYear', 'DDD');\u000a\u000a    // PRIORITY\u000a    addUnitPriority('dayOfYear', 4);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('DDD', match1to3);\u000a    addRegexToken('DDDD', match3);\u000a    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\u000a        config._dayOfYear = toInt(input);\u000a    });\u000a\u000a    // HELPERS\u000a\u000a    // MOMENTS\u000a\u000a    function getSetDayOfYear(input) {\u000a        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\u000a        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\u000a    }\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('m', ['mm', 2], 0, 'minute');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('minute', 'm');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('minute', 14);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('m', match1to2);\u000a    addRegexToken('mm', match1to2, match2);\u000a    addParseToken(['m', 'mm'], MINUTE);\u000a\u000a    // MOMENTS\u000a\u000a    var getSetMinute = makeGetSet('Minutes', false);\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('s', ['ss', 2], 0, 'second');\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('second', 's');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('second', 15);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('s', match1to2);\u000a    addRegexToken('ss', match1to2, match2);\u000a    addParseToken(['s', 'ss'], SECOND);\u000a\u000a    // MOMENTS\u000a\u000a    var getSetSecond = makeGetSet('Seconds', false);\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('S', 0, 0, function () {\u000a        return ~~(this.millisecond() / 100);\u000a    });\u000a\u000a    addFormatToken(0, ['SS', 2], 0, function () {\u000a        return ~~(this.millisecond() / 10);\u000a    });\u000a\u000a    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\u000a    addFormatToken(0, ['SSSS', 4], 0, function () {\u000a        return this.millisecond() * 10;\u000a    });\u000a    addFormatToken(0, ['SSSSS', 5], 0, function () {\u000a        return this.millisecond() * 100;\u000a    });\u000a    addFormatToken(0, ['SSSSSS', 6], 0, function () {\u000a        return this.millisecond() * 1000;\u000a    });\u000a    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\u000a        return this.millisecond() * 10000;\u000a    });\u000a    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\u000a        return this.millisecond() * 100000;\u000a    });\u000a    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\u000a        return this.millisecond() * 1000000;\u000a    });\u000a\u000a    // ALIASES\u000a\u000a    addUnitAlias('millisecond', 'ms');\u000a\u000a    // PRIORITY\u000a\u000a    addUnitPriority('millisecond', 16);\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('S', match1to3, match1);\u000a    addRegexToken('SS', match1to3, match2);\u000a    addRegexToken('SSS', match1to3, match3);\u000a\u000a    var token;\u000a    for (token = 'SSSS'; token.length <= 9; token += 'S') {\u000a        addRegexToken(token, matchUnsigned);\u000a    }\u000a\u000a    function parseMs(input, array) {\u000a        array[MILLISECOND] = toInt(('0.' + input) * 1000);\u000a    }\u000a\u000a    for (token = 'S'; token.length <= 9; token += 'S') {\u000a        addParseToken(token, parseMs);\u000a    }\u000a    // MOMENTS\u000a\u000a    var getSetMillisecond = makeGetSet('Milliseconds', false);\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('z', 0, 0, 'zoneAbbr');\u000a    addFormatToken('zz', 0, 0, 'zoneName');\u000a\u000a    // MOMENTS\u000a\u000a    function getZoneAbbr() {\u000a        return this._isUTC ? 'UTC' : '';\u000a    }\u000a\u000a    function getZoneName() {\u000a        return this._isUTC ? 'Coordinated Universal Time' : '';\u000a    }\u000a\u000a    var momentPrototype__proto = Moment.prototype;\u000a\u000a    momentPrototype__proto.add = add_subtract__add;\u000a    momentPrototype__proto.calendar = moment_calendar__calendar;\u000a    momentPrototype__proto.clone = clone;\u000a    momentPrototype__proto.diff = diff;\u000a    momentPrototype__proto.endOf = endOf;\u000a    momentPrototype__proto.format = format;\u000a    momentPrototype__proto.from = from;\u000a    momentPrototype__proto.fromNow = fromNow;\u000a    momentPrototype__proto.to = to;\u000a    momentPrototype__proto.toNow = toNow;\u000a    momentPrototype__proto.get = stringGet;\u000a    momentPrototype__proto.invalidAt = invalidAt;\u000a    momentPrototype__proto.isAfter = isAfter;\u000a    momentPrototype__proto.isBefore = isBefore;\u000a    momentPrototype__proto.isBetween = isBetween;\u000a    momentPrototype__proto.isSame = isSame;\u000a    momentPrototype__proto.isSameOrAfter = isSameOrAfter;\u000a    momentPrototype__proto.isSameOrBefore = isSameOrBefore;\u000a    momentPrototype__proto.isValid = moment_valid__isValid;\u000a    momentPrototype__proto.lang = lang;\u000a    momentPrototype__proto.locale = locale;\u000a    momentPrototype__proto.localeData = localeData;\u000a    momentPrototype__proto.max = prototypeMax;\u000a    momentPrototype__proto.min = prototypeMin;\u000a    momentPrototype__proto.parsingFlags = parsingFlags;\u000a    momentPrototype__proto.set = stringSet;\u000a    momentPrototype__proto.startOf = startOf;\u000a    momentPrototype__proto.subtract = add_subtract__subtract;\u000a    momentPrototype__proto.toArray = toArray;\u000a    momentPrototype__proto.toObject = toObject;\u000a    momentPrototype__proto.toDate = toDate;\u000a    momentPrototype__proto.toISOString = moment_format__toISOString;\u000a    momentPrototype__proto.toJSON = toJSON;\u000a    momentPrototype__proto.toString = toString;\u000a    momentPrototype__proto.unix = unix;\u000a    momentPrototype__proto.valueOf = to_type__valueOf;\u000a    momentPrototype__proto.creationData = creationData;\u000a\u000a    // Year\u000a    momentPrototype__proto.year = getSetYear;\u000a    momentPrototype__proto.isLeapYear = getIsLeapYear;\u000a\u000a    // Week Year\u000a    momentPrototype__proto.weekYear = getSetWeekYear;\u000a    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;\u000a\u000a    // Quarter\u000a    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;\u000a\u000a    // Month\u000a    momentPrototype__proto.month = getSetMonth;\u000a    momentPrototype__proto.daysInMonth = getDaysInMonth;\u000a\u000a    // Week\u000a    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;\u000a    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;\u000a    momentPrototype__proto.weeksInYear = getWeeksInYear;\u000a    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;\u000a\u000a    // Day\u000a    momentPrototype__proto.date = getSetDayOfMonth;\u000a    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;\u000a    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;\u000a    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;\u000a    momentPrototype__proto.dayOfYear = getSetDayOfYear;\u000a\u000a    // Hour\u000a    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;\u000a\u000a    // Minute\u000a    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;\u000a\u000a    // Second\u000a    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;\u000a\u000a    // Millisecond\u000a    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;\u000a\u000a    // Offset\u000a    momentPrototype__proto.utcOffset = getSetOffset;\u000a    momentPrototype__proto.utc = setOffsetToUTC;\u000a    momentPrototype__proto.local = setOffsetToLocal;\u000a    momentPrototype__proto.parseZone = setOffsetToParsedOffset;\u000a    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;\u000a    momentPrototype__proto.isDST = isDaylightSavingTime;\u000a    momentPrototype__proto.isLocal = isLocal;\u000a    momentPrototype__proto.isUtcOffset = isUtcOffset;\u000a    momentPrototype__proto.isUtc = isUtc;\u000a    momentPrototype__proto.isUTC = isUtc;\u000a\u000a    // Timezone\u000a    momentPrototype__proto.zoneAbbr = getZoneAbbr;\u000a    momentPrototype__proto.zoneName = getZoneName;\u000a\u000a    // Deprecations\u000a    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\u000a    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\u000a    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);\u000a    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\u000a    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\u000a\u000a    var momentPrototype = momentPrototype__proto;\u000a\u000a    function moment__createUnix(input) {\u000a        return local__createLocal(input * 1000);\u000a    }\u000a\u000a    function moment__createInZone() {\u000a        return local__createLocal.apply(null, arguments).parseZone();\u000a    }\u000a\u000a    function preParsePostFormat(string) {\u000a        return string;\u000a    }\u000a\u000a    var prototype__proto = Locale.prototype;\u000a\u000a    prototype__proto.calendar = locale_calendar__calendar;\u000a    prototype__proto.longDateFormat = longDateFormat;\u000a    prototype__proto.invalidDate = invalidDate;\u000a    prototype__proto.ordinal = ordinal;\u000a    prototype__proto.preparse = preParsePostFormat;\u000a    prototype__proto.postformat = preParsePostFormat;\u000a    prototype__proto.relativeTime = relative__relativeTime;\u000a    prototype__proto.pastFuture = pastFuture;\u000a    prototype__proto.set = locale_set__set;\u000a\u000a    // Month\u000a    prototype__proto.months = localeMonths;\u000a    prototype__proto.monthsShort = localeMonthsShort;\u000a    prototype__proto.monthsParse = localeMonthsParse;\u000a    prototype__proto.monthsRegex = monthsRegex;\u000a    prototype__proto.monthsShortRegex = monthsShortRegex;\u000a\u000a    // Week\u000a    prototype__proto.week = localeWeek;\u000a    prototype__proto.firstDayOfYear = localeFirstDayOfYear;\u000a    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;\u000a\u000a    // Day of Week\u000a    prototype__proto.weekdays = localeWeekdays;\u000a    prototype__proto.weekdaysMin = localeWeekdaysMin;\u000a    prototype__proto.weekdaysShort = localeWeekdaysShort;\u000a    prototype__proto.weekdaysParse = localeWeekdaysParse;\u000a\u000a    prototype__proto.weekdaysRegex = weekdaysRegex;\u000a    prototype__proto.weekdaysShortRegex = weekdaysShortRegex;\u000a    prototype__proto.weekdaysMinRegex = weekdaysMinRegex;\u000a\u000a    // Hours\u000a    prototype__proto.isPM = localeIsPM;\u000a    prototype__proto.meridiem = localeMeridiem;\u000a\u000a    function lists__get(format, index, field, setter) {\u000a        var locale = locale_locales__getLocale();\u000a        var utc = create_utc__createUTC().set(setter, index);\u000a        return locale[field](utc, format);\u000a    }\u000a\u000a    function listMonthsImpl(format, index, field) {\u000a        if (typeof format === 'number') {\u000a            index = format;\u000a            format = undefined;\u000a        }\u000a\u000a        format = format || '';\u000a\u000a        if (index != null) {\u000a            return lists__get(format, index, field, 'month');\u000a        }\u000a\u000a        var i;\u000a        var out = [];\u000a        for (i = 0; i < 12; i++) {\u000a            out[i] = lists__get(format, i, field, 'month');\u000a        }\u000a        return out;\u000a    }\u000a\u000a    // ()\u000a    // (5)\u000a    // (fmt, 5)\u000a    // (fmt)\u000a    // (true)\u000a    // (true, 5)\u000a    // (true, fmt, 5)\u000a    // (true, fmt)\u000a    function listWeekdaysImpl(localeSorted, format, index, field) {\u000a        if (typeof localeSorted === 'boolean') {\u000a            if (typeof format === 'number') {\u000a                index = format;\u000a                format = undefined;\u000a            }\u000a\u000a            format = format || '';\u000a        } else {\u000a            format = localeSorted;\u000a            index = format;\u000a            localeSorted = false;\u000a\u000a            if (typeof format === 'number') {\u000a                index = format;\u000a                format = undefined;\u000a            }\u000a\u000a            format = format || '';\u000a        }\u000a\u000a        var locale = locale_locales__getLocale(),\u000a            shift = localeSorted ? locale._week.dow : 0;\u000a\u000a        if (index != null) {\u000a            return lists__get(format, (index + shift) % 7, field, 'day');\u000a        }\u000a\u000a        var i;\u000a        var out = [];\u000a        for (i = 0; i < 7; i++) {\u000a            out[i] = lists__get(format, (i + shift) % 7, field, 'day');\u000a        }\u000a        return out;\u000a    }\u000a\u000a    function lists__listMonths(format, index) {\u000a        return listMonthsImpl(format, index, 'months');\u000a    }\u000a\u000a    function lists__listMonthsShort(format, index) {\u000a        return listMonthsImpl(format, index, 'monthsShort');\u000a    }\u000a\u000a    function lists__listWeekdays(localeSorted, format, index) {\u000a        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\u000a    }\u000a\u000a    function lists__listWeekdaysShort(localeSorted, format, index) {\u000a        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\u000a    }\u000a\u000a    function lists__listWeekdaysMin(localeSorted, format, index) {\u000a        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\u000a    }\u000a\u000a    locale_locales__getSetGlobalLocale('en', {\u000a        ordinalParse: /\u005cd{1,2}(th|st|nd|rd)/,\u000a        ordinal: function (number) {\u000a            var b = number % 10,\u000a                output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\u000a            return number + output;\u000a        }\u000a    });\u000a\u000a    // Side effect imports\u000a    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);\u000a    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);\u000a\u000a    var mathAbs = Math.abs;\u000a\u000a    function duration_abs__abs() {\u000a        var data = this._data;\u000a\u000a        this._milliseconds = mathAbs(this._milliseconds);\u000a        this._days = mathAbs(this._days);\u000a        this._months = mathAbs(this._months);\u000a\u000a        data.milliseconds = mathAbs(data.milliseconds);\u000a        data.seconds = mathAbs(data.seconds);\u000a        data.minutes = mathAbs(data.minutes);\u000a        data.hours = mathAbs(data.hours);\u000a        data.months = mathAbs(data.months);\u000a        data.years = mathAbs(data.years);\u000a\u000a        return this;\u000a    }\u000a\u000a    function duration_add_subtract__addSubtract(duration, input, value, direction) {\u000a        var other = create__createDuration(input, value);\u000a\u000a        duration._milliseconds += direction * other._milliseconds;\u000a        duration._days += direction * other._days;\u000a        duration._months += direction * other._months;\u000a\u000a        return duration._bubble();\u000a    }\u000a\u000a    // supports only 2.0-style add(1, 's') or add(duration)\u000a    function duration_add_subtract__add(input, value) {\u000a        return duration_add_subtract__addSubtract(this, input, value, 1);\u000a    }\u000a\u000a    // supports only 2.0-style subtract(1, 's') or subtract(duration)\u000a    function duration_add_subtract__subtract(input, value) {\u000a        return duration_add_subtract__addSubtract(this, input, value, -1);\u000a    }\u000a\u000a    function absCeil(number) {\u000a        if (number < 0) {\u000a            return Math.floor(number);\u000a        } else {\u000a            return Math.ceil(number);\u000a        }\u000a    }\u000a\u000a    function bubble() {\u000a        var milliseconds = this._milliseconds;\u000a        var days = this._days;\u000a        var months = this._months;\u000a        var data = this._data;\u000a        var seconds, minutes, hours, years, monthsFromDays;\u000a\u000a        // if we have a mix of positive and negative values, bubble down first\u000a        // check: https://github.com/moment/moment/issues/2166\u000a        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\u000a            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\u000a            days = 0;\u000a            months = 0;\u000a        }\u000a\u000a        // The following code bubbles up values, see the tests for\u000a        // examples of what that means.\u000a        data.milliseconds = milliseconds % 1000;\u000a\u000a        seconds = absFloor(milliseconds / 1000);\u000a        data.seconds = seconds % 60;\u000a\u000a        minutes = absFloor(seconds / 60);\u000a        data.minutes = minutes % 60;\u000a\u000a        hours = absFloor(minutes / 60);\u000a        data.hours = hours % 24;\u000a\u000a        days += absFloor(hours / 24);\u000a\u000a        // convert days to months\u000a        monthsFromDays = absFloor(daysToMonths(days));\u000a        months += monthsFromDays;\u000a        days -= absCeil(monthsToDays(monthsFromDays));\u000a\u000a        // 12 months -> 1 year\u000a        years = absFloor(months / 12);\u000a        months %= 12;\u000a\u000a        data.days = days;\u000a        data.months = months;\u000a        data.years = years;\u000a\u000a        return this;\u000a    }\u000a\u000a    function daysToMonths(days) {\u000a        // 400 years have 146097 days (taking into account leap year rules)\u000a        // 400 years have 12 months === 4800\u000a        return days * 4800 / 146097;\u000a    }\u000a\u000a    function monthsToDays(months) {\u000a        // the reverse of daysToMonths\u000a        return months * 146097 / 4800;\u000a    }\u000a\u000a    function as(units) {\u000a        var days;\u000a        var months;\u000a        var milliseconds = this._milliseconds;\u000a\u000a        units = normalizeUnits(units);\u000a\u000a        if (units === 'month' || units === 'year') {\u000a            days = this._days + milliseconds / 864e5;\u000a            months = this._months + daysToMonths(days);\u000a            return units === 'month' ? months : months / 12;\u000a        } else {\u000a            // handle milliseconds separately because of floating point math errors (issue #1867)\u000a            days = this._days + Math.round(monthsToDays(this._months));\u000a            switch (units) {\u000a                case 'week':\u000a                    return days / 7 + milliseconds / 6048e5;\u000a                case 'day':\u000a                    return days + milliseconds / 864e5;\u000a                case 'hour':\u000a                    return days * 24 + milliseconds / 36e5;\u000a                case 'minute':\u000a                    return days * 1440 + milliseconds / 6e4;\u000a                case 'second':\u000a                    return days * 86400 + milliseconds / 1000;\u000a                // Math.floor prevents floating point math errors here\u000a                case 'millisecond':\u000a                    return Math.floor(days * 864e5) + milliseconds;\u000a                default:\u000a                    throw new Error('Unknown unit ' + units);\u000a            }\u000a        }\u000a    }\u000a\u000a    // TODO: Use this.as('ms')?\u000a    function duration_as__valueOf() {\u000a        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\u000a    }\u000a\u000a    function makeAs(alias) {\u000a        return function () {\u000a            return this.as(alias);\u000a        };\u000a    }\u000a\u000a    var asMilliseconds = makeAs('ms');\u000a    var asSeconds = makeAs('s');\u000a    var asMinutes = makeAs('m');\u000a    var asHours = makeAs('h');\u000a    var asDays = makeAs('d');\u000a    var asWeeks = makeAs('w');\u000a    var asMonths = makeAs('M');\u000a    var asYears = makeAs('y');\u000a\u000a    function duration_get__get(units) {\u000a        units = normalizeUnits(units);\u000a        return this[units + 's']();\u000a    }\u000a\u000a    function makeGetter(name) {\u000a        return function () {\u000a            return this._data[name];\u000a        };\u000a    }\u000a\u000a    var milliseconds = makeGetter('milliseconds');\u000a    var seconds = makeGetter('seconds');\u000a    var minutes = makeGetter('minutes');\u000a    var hours = makeGetter('hours');\u000a    var days = makeGetter('days');\u000a    var months = makeGetter('months');\u000a    var years = makeGetter('years');\u000a\u000a    function weeks() {\u000a        return absFloor(this.days() / 7);\u000a    }\u000a\u000a    var round = Math.round;\u000a    var thresholds = {\u000a        s: 45, // seconds to minute\u000a        m: 45, // minutes to hour\u000a        h: 22, // hours to day\u000a        d: 26, // days to month\u000a        M: 11 // months to year\u000a    };\u000a\u000a    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\u000a    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\u000a        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\u000a    }\u000a\u000a    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {\u000a        var duration = create__createDuration(posNegDuration).abs();\u000a        var seconds = round(duration.as('s'));\u000a        var minutes = round(duration.as('m'));\u000a        var hours = round(duration.as('h'));\u000a        var days = round(duration.as('d'));\u000a        var months = round(duration.as('M'));\u000a        var years = round(duration.as('y'));\u000a\u000a        var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];\u000a\u000a        a[2] = withoutSuffix;\u000a        a[3] = +posNegDuration > 0;\u000a        a[4] = locale;\u000a        return substituteTimeAgo.apply(null, a);\u000a    }\u000a\u000a    // This function allows you to set the rounding function for relative time strings\u000a    function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {\u000a        if (roundingFunction === undefined) {\u000a            return round;\u000a        }\u000a        if (typeof roundingFunction === 'function') {\u000a            round = roundingFunction;\u000a            return true;\u000a        }\u000a        return false;\u000a    }\u000a\u000a    // This function allows you to set a threshold for relative time strings\u000a    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {\u000a        if (thresholds[threshold] === undefined) {\u000a            return false;\u000a        }\u000a        if (limit === undefined) {\u000a            return thresholds[threshold];\u000a        }\u000a        thresholds[threshold] = limit;\u000a        return true;\u000a    }\u000a\u000a    function humanize(withSuffix) {\u000a        var locale = this.localeData();\u000a        var output = duration_humanize__relativeTime(this, !withSuffix, locale);\u000a\u000a        if (withSuffix) {\u000a            output = locale.pastFuture(+this, output);\u000a        }\u000a\u000a        return locale.postformat(output);\u000a    }\u000a\u000a    var iso_string__abs = Math.abs;\u000a\u000a    function iso_string__toISOString() {\u000a        // for ISO strings we do not use the normal bubbling rules:\u000a        //  * milliseconds bubble up until they become hours\u000a        //  * days do not bubble at all\u000a        //  * months bubble up until they become years\u000a        // This is because there is no context-free conversion between hours and days\u000a        // (think of clock changes)\u000a        // and also not between days and months (28-31 days per month)\u000a        var seconds = iso_string__abs(this._milliseconds) / 1000;\u000a        var days = iso_string__abs(this._days);\u000a        var months = iso_string__abs(this._months);\u000a        var minutes, hours, years;\u000a\u000a        // 3600 seconds -> 60 minutes -> 1 hour\u000a        minutes = absFloor(seconds / 60);\u000a        hours = absFloor(minutes / 60);\u000a        seconds %= 60;\u000a        minutes %= 60;\u000a\u000a        // 12 months -> 1 year\u000a        years = absFloor(months / 12);\u000a        months %= 12;\u000a\u000a        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\u000a        var Y = years;\u000a        var M = months;\u000a        var D = days;\u000a        var h = hours;\u000a        var m = minutes;\u000a        var s = seconds;\u000a        var total = this.asSeconds();\u000a\u000a        if (!total) {\u000a            // this is the same as C#'s (Noda) and python (isodate)...\u000a            // but not other JS (goog.date)\u000a            return 'P0D';\u000a        }\u000a\u000a        return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');\u000a    }\u000a\u000a    var duration_prototype__proto = Duration.prototype;\u000a\u000a    duration_prototype__proto.abs = duration_abs__abs;\u000a    duration_prototype__proto.add = duration_add_subtract__add;\u000a    duration_prototype__proto.subtract = duration_add_subtract__subtract;\u000a    duration_prototype__proto.as = as;\u000a    duration_prototype__proto.asMilliseconds = asMilliseconds;\u000a    duration_prototype__proto.asSeconds = asSeconds;\u000a    duration_prototype__proto.asMinutes = asMinutes;\u000a    duration_prototype__proto.asHours = asHours;\u000a    duration_prototype__proto.asDays = asDays;\u000a    duration_prototype__proto.asWeeks = asWeeks;\u000a    duration_prototype__proto.asMonths = asMonths;\u000a    duration_prototype__proto.asYears = asYears;\u000a    duration_prototype__proto.valueOf = duration_as__valueOf;\u000a    duration_prototype__proto._bubble = bubble;\u000a    duration_prototype__proto.get = duration_get__get;\u000a    duration_prototype__proto.milliseconds = milliseconds;\u000a    duration_prototype__proto.seconds = seconds;\u000a    duration_prototype__proto.minutes = minutes;\u000a    duration_prototype__proto.hours = hours;\u000a    duration_prototype__proto.days = days;\u000a    duration_prototype__proto.weeks = weeks;\u000a    duration_prototype__proto.months = months;\u000a    duration_prototype__proto.years = years;\u000a    duration_prototype__proto.humanize = humanize;\u000a    duration_prototype__proto.toISOString = iso_string__toISOString;\u000a    duration_prototype__proto.toString = iso_string__toISOString;\u000a    duration_prototype__proto.toJSON = iso_string__toISOString;\u000a    duration_prototype__proto.locale = locale;\u000a    duration_prototype__proto.localeData = localeData;\u000a\u000a    // Deprecations\u000a    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);\u000a    duration_prototype__proto.lang = lang;\u000a\u000a    // Side effect imports\u000a\u000a    // FORMATTING\u000a\u000a    addFormatToken('X', 0, 0, 'unix');\u000a    addFormatToken('x', 0, 0, 'valueOf');\u000a\u000a    // PARSING\u000a\u000a    addRegexToken('x', matchSigned);\u000a    addRegexToken('X', matchTimestamp);\u000a    addParseToken('X', function (input, array, config) {\u000a        config._d = new Date(parseFloat(input, 10) * 1000);\u000a    });\u000a    addParseToken('x', function (input, array, config) {\u000a        config._d = new Date(toInt(input));\u000a    });\u000a\u000a    // Side effect imports\u000a\u000a\u000a    utils_hooks__hooks.version = '2.14.1';\u000a\u000a    setHookCallback(local__createLocal);\u000a\u000a    utils_hooks__hooks.fn = momentPrototype;\u000a    utils_hooks__hooks.min = min;\u000a    utils_hooks__hooks.max = max;\u000a    utils_hooks__hooks.now = now;\u000a    utils_hooks__hooks.utc = create_utc__createUTC;\u000a    utils_hooks__hooks.unix = moment__createUnix;\u000a    utils_hooks__hooks.months = lists__listMonths;\u000a    utils_hooks__hooks.isDate = isDate;\u000a    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;\u000a    utils_hooks__hooks.invalid = valid__createInvalid;\u000a    utils_hooks__hooks.duration = create__createDuration;\u000a    utils_hooks__hooks.isMoment = isMoment;\u000a    utils_hooks__hooks.weekdays = lists__listWeekdays;\u000a    utils_hooks__hooks.parseZone = moment__createInZone;\u000a    utils_hooks__hooks.localeData = locale_locales__getLocale;\u000a    utils_hooks__hooks.isDuration = isDuration;\u000a    utils_hooks__hooks.monthsShort = lists__listMonthsShort;\u000a    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;\u000a    utils_hooks__hooks.defineLocale = defineLocale;\u000a    utils_hooks__hooks.updateLocale = updateLocale;\u000a    utils_hooks__hooks.locales = locale_locales__listLocales;\u000a    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;\u000a    utils_hooks__hooks.normalizeUnits = normalizeUnits;\u000a    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;\u000a    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;\u000a    utils_hooks__hooks.calendarFormat = getCalendarFormat;\u000a    utils_hooks__hooks.prototype = momentPrototype;\u000a\u000a    var _moment = utils_hooks__hooks;\u000a\u000a    return _moment;\u000a});\u000a\u000a
p1
.