V/*\u000a  DotLayer Efrem Rensi, 2017,\u000a  based on L.CanvasLayer by Stanislav Sumbera,  2016 , sumbera.com\u000a  license MIT\u000a*/\u000a\u000a// -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7\u000a//------------------------------------------------------------------------------\u000aL.DomUtil.setTransform = L.DomUtil.setTransform || function (el, offset, scale) {\u000a    var pos = offset || new L.Point(0, 0);\u000a\u000a    el.style[L.DomUtil.TRANSFORM] = (L.Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");\u000a};\u000a\u000a// -- support for both  0.0.7 and 1.0.0 rc2 leaflet\u000aL.DotLayer = (L.Layer ? L.Layer : L.Class).extend({\u000a\u000a    _pane: "shadowPane",\u000a    two_pi: 2 * Math.PI,\u000a    target_fps: 32,\u000a    smoothFactor: 1.0,\u000a    _tThresh: 100000000.0,\u000a    C1: 1000000.0,\u000a    C2: 200.0,\u000a\u000a    options: {\u000a        startPaused: false,\u000a        showPaths: true,\u000a        normal: {\u000a            dotColor: "#000000",\u000a            pathColor: "#000000",\u000a            pathOpacity: 0.5,\u000a            pathWidth: 1\u000a        },\u000a        selected: {\u000a            dotColor: "#FFFFFF",\u000a            dotStrokeColor: "#FFFFFF",\u000a            pathColor: "#000000",\u000a            pathOpacity: 0.7,\u000a            pathWidth: 3\u000a        }\u000a    },\u000a\u000a    // -- initialized is called on prototype\u000a    initialize: function (items, options) {\u000a        this._map = null;\u000a        this._dotCanvas = null;\u000a        this._lineCanvas = null;\u000a        this._capturing = null;\u000a        this._dotCtx = null;\u000a        this._lineCtx = null;\u000a        this._frame = null;\u000a        this._items = items || null;\u000a        this._timeOffset = 0;\u000a        this._colorPalette = [];\u000a        L.setOptions(this, options);\u000a        this._paused = this.options.startPaused;\u000a        this._timePaused = Date.now();\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    _onLayerDidResize: function (resizeEvent) {\u000a        let newWidth = resizeEvent.newSize.x,\u000a            newHeight = resizeEvent.newSize.y;\u000a\u000a        this._dotCanvas.width = newWidth;\u000a        this._dotCanvas.height = newHeight;\u000a\u000a        this._lineCanvas.width = newWidth;\u000a        this._lineCanvas.height = newHeight;\u000a\u000a        this._onLayerDidMove();\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    _onLayerDidMove: function () {\u000a        this._mapMoving = false;\u000a\u000a        let topLeft = this._map.containerPointToLayerPoint([0, 0]);\u000a\u000a        this._dotCtx.clearRect(0, 0, this._dotCanvas.width, this._dotCanvas.height);\u000a        L.DomUtil.setPosition(this._dotCanvas, topLeft);\u000a\u000a        this._lineCtx.clearRect(0, 0, this._lineCanvas.width, this._lineCanvas.height);\u000a        L.DomUtil.setPosition(this._lineCanvas, topLeft);\u000a\u000a        this._setupWindow();\u000a\u000a        if (this._paused) {\u000a            this.drawLayer(this._timePaused);\u000a        } else {\u000a            this.animate();\u000a        }\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    getEvents: function () {\u000a        var events = {\u000a            movestart: function () {\u000a                this._mapMoving = true;\u000a            },\u000a            moveend: this._onLayerDidMove,\u000a            resize: this._onLayerDidResize\u000a        };\u000a\u000a        if (this._map.options.zoomAnimation && L.Browser.any3d) {\u000a            events.zoomanim = this._animateZoom;\u000a        }\u000a\u000a        return events;\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    onAdd: function (map) {\u000a        this._map = map;\u000a\u000a        let size = this._map.getSize(),\u000a            zoomAnimated = this._map.options.zoomAnimation && L.Browser.any3d;\u000a\u000a        // dotlayer canvas\u000a        this._dotCanvas = L.DomUtil.create("canvas", "leaflet-layer");\u000a        this._dotCanvas.width = size.x;\u000a        this._dotCanvas.height = size.y;\u000a        this._dotCtx = this._dotCanvas.getContext("2d");\u000a        L.DomUtil.addClass(this._dotCanvas, "leaflet-zoom-" + (zoomAnimated ? "animated" : "hide"));\u000a        map._panes.shadowPane.style.pointerEvents = "none";\u000a        map._panes.shadowPane.appendChild(this._dotCanvas);\u000a\u000a        // create Canvas for polyline-ish things\u000a        this._lineCanvas = L.DomUtil.create("canvas", "leaflet-layer");\u000a        this._lineCanvas.width = size.x;\u000a        this._lineCanvas.height = size.y;\u000a        this._lineCtx = this._lineCanvas.getContext("2d");\u000a        this._lineCtx.lineCap = "round";\u000a        this._lineCtx.lineJoin = "round";\u000a        L.DomUtil.addClass(this._lineCanvas, "leaflet-zoom-" + (zoomAnimated ? "animated" : "hide"));\u000a        map._panes.overlayPane.appendChild(this._lineCanvas);\u000a\u000a        map.on(this.getEvents(), this);\u000a\u000a        if (this._items) {\u000a\u000a            // Set dotColors for these items\u000a            let itemsList = Object.values(this._items),\u000a                numItems = itemsList.length;\u000a\u000a            this._colorPalette = colorPalette(numItems);\u000a            // this._colorPalette = createPalette( numItems );\u000a            for (let i = 0; i < numItems; i++) {\u000a                itemsList[i].dotColor = this._colorPalette[i];\u000a            }\u000a\u000a            this._onLayerDidMove();\u000a        }\u000a    },\u000a\u000a    //-------------------------------------------------------------\u000a    onRemove: function (map) {\u000a        this.onLayerWillUnmount && this.onLayerWillUnmount(); // -- callback\u000a\u000a        map._panes.shadowPane.removeChild(this._dotCanvas);\u000a        this._dotCanvas = null;\u000a\u000a        map._panes.overlayPane.removeChild(this._lineCanvas);\u000a        this._lineCanvas = null;\u000a\u000a        map.off(this.getEvents(), this);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    addTo: function (map) {\u000a        map.addLayer(this);\u000a        return this;\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    LatLonToMercator: function (latlon) {\u000a        return {\u000a            x: latlon.lng * 6378137 * Math.PI / 180,\u000a            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\u000a        };\u000a    },\u000a\u000a    // -------------------------------------------------------------------\u000a    _setupWindow: function () {\u000a        if (!this._map || !this._items) {\u000a            return;\u000a        }\u000a\u000a        const perf_t0 = performance.now();\u000a\u000a        // Get new map orientation\u000a        this._zoom = this._map.getZoom();\u000a        this._center = this._map.getCenter;\u000a        this._size = this._map.getSize();\u000a\u000a        this._latLngBounds = this._map.getBounds();\u000a        this._mapPanePos = this._map._getMapPanePos();\u000a        this._pxOrigin = this._map.getPixelOrigin();\u000a        this._pxBounds = this._map.getPixelBounds();\u000a        this._pxOffset = this._mapPanePos.subtract(this._pxOrigin)._add(new L.Point(0.5, 0.5));\u000a\u000a        var lineCtx = this._lineCtx,\u000a            z = this._zoom,\u000a            ppos = this._mapPanePos,\u000a            pxOrigin = this._pxOrigin,\u000a            pxBounds = this._pxBounds,\u000a            items = this._items;\u000a\u000a        this._dotCtx.strokeStyle = this.options.selected.dotStrokeColor;\u000a\u000a        this._dotSize = Math.max(1, ~~(Math.log(z) + 0.5));\u000a        this._dotOffset = ~~(this._dotSize / 2 + 0.5);\u000a        this._zoomFactor = 1 / Math.pow(2, z);\u000a\u000a        var tThresh = this._tThresh * DotLayer._zoomFactor;\u000a\u000a        // console.log( `zoom=${z}\u005cnmapPanePos=${ppos}\u005cnsize=${this._size}\u005cn` +\u000a        //             `pxOrigin=${pxOrigin}\u005cnpxBounds=[${pxBounds.min}, ${pxBounds.max}]`\u000a        //              );\u000a\u000a\u000a        this._processedItems = {};\u000a\u000a        let pxOffx = this._pxOffset.x,\u000a            pxOffy = this._pxOffset.y;\u000a\u000a        for (let id in items) {\u000a            if (!items.hasOwnProperty(id)) {\u000a                //The current property is not a direct property of p\u000a                continue;\u000a            }\u000a\u000a            let A = this._items[id];\u000a            drawingLine = false;\u000a\u000a            // console.log("processing "+A.id);\u000a\u000a            if (!A.projected) {\u000a                A.projected = {};\u000a            }\u000a\u000a            if (A.latLngTime && this._latLngBounds.overlaps(A.bounds)) {\u000a                let projected = A.projected[z],\u000a                    llt = A.latLngTime;\u000a\u000a                // Compute projected points if necessary\u000a                if (!projected) {\u000a                    let numPoints = llt.length / 3,\u000a                        projectedObjs = new Array(numPoints);\u000a\u000a                    for (let i = 0, p, idx; i < numPoints; i++) {\u000a                        idx = 3 * i;\u000a                        p = this._map.project([llt[idx], llt[idx + 1]]);\u000a                        p.t = llt[idx + 2];\u000a                        projectedObjs[i] = p;\u000a                    }\u000a\u000a                    projectedObjs = L.LineUtil.simplify(projectedObjs, this.smoothFactor);\u000a\u000a                    // now projectedObjs is an Array of objects, so we convert it\u000a                    // to a Float32Array\u000a                    let numObjs = projectedObjs.length,\u000a                        projected = new Float32Array(numObjs * 3);\u000a                    for (let i = 0, obj, idx; i < numObjs; i++) {\u000a                        obj = projectedObjs[i];\u000a                        idx = 3 * i;\u000a                        projected[idx] = obj.x;\u000a                        projected[idx + 1] = obj.y;\u000a                        projected[idx + 2] = obj.t;\u000a                    }\u000a                    A.projected[z] = projected;\u000a                }\u000a\u000a                projected = A.projected[z];\u000a                // determine whether or not each projected point is in the\u000a                // currently visible area\u000a                let numProjected = projected.length / 3,\u000a                    numSegs = numProjected - 1,\u000a                    segGood = new Int8Array(numProjected - 2),\u000a                    goodSegCount = 0,\u000a                    t0 = projected[2],\u000a                    in0 = this._pxBounds.contains([projected[0], projected[1]]);\u000a\u000a                for (let i = 1, idx; i < numSegs; i++) {\u000a                    let idx = 3 * i,\u000a                        p = projected.slice(idx, idx + 3),\u000a                        in1 = this._pxBounds.contains([p[0], p[1]]),\u000a                        t1 = p[2],\u000a\u000a                    // isGood = (in0 && in1 && (t1-t0 < tThresh) )? 1:0;\u000a                    isGood = (in0 || in1) && t1 - t0 < tThresh ? 1 : 0;\u000a                    segGood[i - 1] = isGood;\u000a                    goodSegCount += isGood;\u000a                    in0 = in1;\u000a                    t0 = t1;\u000a                }\u000a\u000a                // console.log(segGood);\u000a                if (goodSegCount == 0) {\u000a                    continue;\u000a                }\u000a\u000a                let dP = new Float32Array(goodSegCount * 3);\u000a\u000a                for (let i = 0, j = 0; i < numSegs; i++) {\u000a                    // Is the current segment in the visible area?\u000a                    if (segGood[i]) {\u000a                        let pidx = 3 * i,\u000a                            didx = 3 * j,\u000a                            p = projected.slice(pidx, pidx + 6);\u000a                        j++;\u000a\u000a                        // p[0:2] are p1.x, p1.y, and p1.t\u000a                        // p[3:5] are p2.x, p2.y, and p2.t\u000a\u000a                        // Compute derivative for this segment\u000a                        dP[didx] = pidx;\u000a                        dt = p[5] - p[2];\u000a                        dP[didx + 1] = (p[3] - p[0]) / dt;\u000a                        dP[didx + 2] = (p[4] - p[1]) / dt;\u000a\u000a                        if (this.options.showPaths) {\u000a                            if (!drawingLine) {\u000a                                lineCtx.beginPath();\u000a                                drawingLine = true;\u000a                            }\u000a                            // draw polyline segment from p1 to p2\u000a                            let c1x = ~~(p[0] + pxOffx),\u000a                                c1y = ~~(p[1] + pxOffy),\u000a                                c2x = ~~(p[3] + pxOffx),\u000a                                c2y = ~~(p[4] + pxOffy);\u000a                            lineCtx.moveTo(c1x, c1y);\u000a                            lineCtx.lineTo(c2x, c2y);\u000a                        }\u000a                    }\u000a                }\u000a\u000a                if (this.options.showPaths) {\u000a                    if (drawingLine) {\u000a                        lineType = A.highlighted ? "selected" : "normal";\u000a                        lineCtx.globalAlpha = this.options[lineType].pathOpacity;\u000a                        lineCtx.lineWidth = this.options[lineType].pathWidth;\u000a                        lineCtx.strokeStyle = A.path_color || this.options[lineType].pathColor;\u000a                        lineCtx.stroke();\u000a                    } else {\u000a                        lineCtx.stroke();\u000a                    }\u000a                }\u000a\u000a                this._processedItems[id] = {\u000a                    dP: dP,\u000a                    P: projected,\u000a                    dotColor: A.dotColor,\u000a                    startTime: A.startTime,\u000a                    totSec: projected.slice(-1)[0]\u000a                };\u000a            }\u000a        }\u000a\u000a        elapsed = (performance.now() - perf_t0).toFixed(2);\u000a        // console.log(`dot context update took ${elapsed} ms`);\u000a        // console.log(this._processedItems);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    drawDots: function (obj, now, highlighted) {\u000a        var P = obj.P,\u000a            dP = obj.dP,\u000a            len_dP = dP.length,\u000a            totSec = obj.totSec,\u000a            period = this._period,\u000a            s = this._timeScale * (now - obj.startTime),\u000a            xmax = this._size.x,\u000a            ymax = this._size.y,\u000a            ctx = this._dotCtx,\u000a            dotSize = this._dotSize,\u000a            dotOffset = this._dotOffset,\u000a            two_pi = this.two_pi,\u000a            xOffset = this._pxOffset.x,\u000a            yOffset = this._pxOffset.y;\u000a\u000a        var timeOffset = s % period,\u000a            count = 0,\u000a            idx = dP[0],\u000a            dx = dP[1],\u000a            dy = dP[2],\u000a            p = P.slice(idx, idx + 3);\u000a\u000a        if (highlighted) {\u000a            ctx.fillStyle = obj.dotColor || this.options.selected.dotColor;\u000a        }\u000a\u000a        if (timeOffset < 0) {\u000a            timeOffset += period;\u000a        }\u000a\u000a        for (let t = timeOffset, i = 0, dt; t < totSec; t += period) {\u000a            if (t >= P[idx + 5]) {\u000a                while (t >= P[idx + 5]) {\u000a                    i += 3;\u000a                    idx = dP[i];\u000a                    if (i >= len_dP) {\u000a                        return count;\u000a                    }\u000a                }\u000a                p = P.slice(idx, idx + 3);\u000a                dx = dP[i + 1];\u000a                dy = dP[i + 2];\u000a            }\u000a\u000a            dt = t - p[2];\u000a\u000a            if (dt > 0) {\u000a                let lx = ~~(p[0] + dx * dt + xOffset),\u000a                    ly = ~~(p[1] + dy * dt + yOffset);\u000a\u000a                if (lx >= 0 && lx <= xmax && ly >= 0 && ly <= ymax) {\u000a                    if (highlighted) {\u000a                        ctx.beginPath();\u000a                        ctx.arc(lx, ly, dotSize, 0, two_pi);\u000a                        ctx.fill();\u000a                        ctx.closePath();\u000a                        ctx.stroke();\u000a                    } else {\u000a                        ctx.fillRect(lx - dotOffset, ly - dotOffset, dotSize, dotSize);\u000a                    }\u000a                    count++;\u000a                }\u000a            }\u000a        }\u000a        return count;\u000a    },\u000a\u000a    drawLayer: function (now) {\u000a        if (!this._map) {\u000a            return;\u000a        }\u000a\u000a        let ctx = this._dotCtx,\u000a            zoom = this._zoom,\u000a            count = 0,\u000a            t0 = performance.now(),\u000a            item,\u000a            items = this._items,\u000a            pItem,\u000a            pItems = this._processedItems,\u000a            highlighted_items = [],\u000a            zf = this._zoomFactor;\u000a\u000a        ctx.clearRect(0, 0, this._dotCanvas.width, this._dotCanvas.height);\u000a        ctx.fillStyle = this.options.normal.dotColor;\u000a\u000a        this._timeScale = this.C2 * zf;\u000a        this._period = this.C1 * zf;\u000a\u000a        for (let id in pItems) {\u000a            item = pItems[id];\u000a            if (items[id].highlighted) {\u000a                highlighted_items.push(item);\u000a            } else {\u000a                count += this.drawDots(item, now, false);\u000a            }\u000a        }\u000a\u000a        // Now plot highlighted paths\u000a        let hlen = highlighted_items.length;\u000a        if (hlen) {\u000a            for (let i = 0; i < hlen; i++) {\u000a                item = highlighted_items[i];\u000a                count += this.drawDots(item, now, true);\u000a            }\u000a        }\u000a\u000a        if (fps_display) {\u000a            let periodInSecs = this.periodInSecs(),\u000a                progress = (now / 1000 % periodInSecs).toFixed(1),\u000a                elapsed = (performance.now() - t0).toFixed(1);\u000a\u000a            fps_display.update(now, `${elapsed} ms/f, n=${count}, z=${this._zoom},\u005cnP=${progress}/${periodInSecs.toFixed(2)}`);\u000a        }\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    animate: function () {\u000a        this._paused = false;\u000a        if (this._timePaused) {\u000a            this._timeOffset = Date.now() - this._timePaused;\u000a            this._timePaused = null;\u000a        }\u000a        this.lastCalledTime = 0;\u000a        this.minDelay = ~~(1000 / this.target_fps + 0.5);\u000a        this._frame = L.Util.requestAnimFrame(this._animate, this);\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    pause: function () {\u000a        this._paused = true;\u000a    },\u000a\u000a    // --------------------------------------------------------------------\u000a    _animate: function () {\u000a        if (!this._frame) {\u000a            return;\u000a        }\u000a        this._frame = null;\u000a        // debugger;\u000a\u000a        let ts = Date.now(),\u000a            now = ts - this._timeOffset,\u000a            capturing = this._capturing;\u000a\u000a        if (this._paused || this._mapMoving) {\u000a            // Ths is so we can start where we left off when we resume\u000a            this._timePaused = ts;\u000a            return;\u000a        }\u000a\u000a        if (capturing || now - this.lastCalledTime > this.minDelay) {\u000a            this.lastCalledTime = now;\u000a            this.drawLayer(now);\u000a\u000a            capturing && this._capturer.capture(this._dotCanvas);\u000a        }\u000a\u000a        this._frame = L.Util.requestAnimFrame(this._animate, this);\u000a    },\u000a\u000a    // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7\u000a    //------------------------------------------------------------------------------\u000a    _setTransform: function (el, offset, scale) {\u000a        var pos = offset || new L.Point(0, 0);\u000a\u000a        el.style[L.DomUtil.TRANSFORM] = (L.Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");\u000a    },\u000a\u000a    //------------------------------------------------------------------------------\u000a    _animateZoom: function (e) {\u000a        var scale = this._map.getZoomScale(e.zoom);\u000a\u000a        // -- different calc of offset in leaflet 1.0.0 and 0.0.7 thanks for 1.0.0-rc2 calc @jduggan1\u000a        var offset = L.Layer ? this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center) : this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\u000a\u000a        L.DomUtil.setTransform(this._dotCanvas, offset, scale);\u000a        L.DomUtil.setTransform(this._lineCanvas, offset, scale);\u000a    },\u000a\u000a    periodInSecs: function () {\u000a        return this._period / (this._timeScale * 1000);\u000a    },\u000a\u000a    getMapImageCanvas: function () {\u000a        let mapImageCanvas;\u000a\u000a        leafletImage(this._map, function (err, canvas) {\u000a            download(canvas.toDataURL("image/png"), "mapView.png", "image/png");\u000a            console.log("leaflet-image: " + err);\u000a            mapImageCanvas = canvas;\u000a        });\u000a        return mapImageCanvas;\u000a    },\u000a\u000a    captureCycle: function () {\u000a        let periodInSecs = this.periodInSecs();\u000a        if (periodInSecs > 5) {\u000a            return 0;\u000a        }\u000a\u000a        this.pause();\u000a        let mapCanvas = getMapImageCanvas(),\u000a            startTime = Date.now();\u000a    },\u000a\u000a    // ------------------------------------------------------\u000a    startCapture: function () {\u000a        let periodInSecs = this.periodInSecs();\u000a        if (periodInSecs > 5) {\u000a            return 0;\u000a        }\u000a\u000a        let mapImageCanvas = getMapImageCanvas();\u000a        this._capturer = new CCapture({\u000a            name: "movingPath",\u000a            format: "gif",\u000a            quality: 5,\u000a            workersPath: 'static/js/',\u000a            framerate: 30,\u000a            timeLimit: periodInSecs,\u000a            display: true,\u000a            verbose: false\u000a        });\u000a\u000a        this._capturing = true;\u000a        this._capturer.start();\u000a        return periodInSecs;\u000a    },\u000a\u000a    stopCapture: function () {\u000a        this._capturer.stop();\u000a        this._capturing = false;\u000a\u000a        // default save, will download automatically a file called {name}.extension (webm/gif/tar)\u000a        this._capturer.save();\u000a        // delete currentTime;\u000a\u000a        // // custom save, will get a blob in the callback\u000a        // capturer.save( function( blob ) { /* ... */ } );\u000a    }\u000a});\u000a\u000aL.dotLayer = function (items, options) {\u000a    return new L.DotLayer(items, options);\u000a};\u000a\u000a// ---------------------------------------------------------------------------\u000a\u000a/*\u000a    From "Making annoying rainbows in javascript"\u000a    A tutorial by jim bumgardner\u000a*/\u000afunction makeColorGradient(frequency1, frequency2, frequency3, phase1, phase2, phase3, center, width, len) {\u000a    let palette = new Array(len);\u000a\u000a    if (center == undefined) center = 128;\u000a    if (width == undefined) width = 127;\u000a    if (len == undefined) len = 50;\u000a\u000a    for (let i = 0; i < len; ++i) {\u000a        let r = Math.round(Math.sin(frequency1 * i + phase1) * width + center),\u000a            g = Math.round(Math.sin(frequency2 * i + phase2) * width + center),\u000a            b = Math.round(Math.sin(frequency3 * i + phase3) * width + center);\u000a        palette[i] = `rgb(${r}, ${g}, ${b})`;\u000a    }\u000a    return palette;\u000a}\u000a\u000afunction colorPalette(n) {\u000a    center = 128;\u000a    width = 127;\u000a    steps = 10;\u000a    frequency = 2 * Math.PI / steps;\u000a    return makeColorGradient(frequency, frequency, frequency, 0, 2, 4, center, width, n);\u000a}\u000a\u000a
p1
.