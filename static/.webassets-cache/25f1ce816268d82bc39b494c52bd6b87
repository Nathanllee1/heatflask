V/*\u000a	var vid = new Whammy.Video();\u000a	vid.add(canvas or data url)\u000a	vid.compile()\u000a*/\u000a\u000awindow.Whammy = function () {\u000a	// in this case, frames has a very specific meaning, which will be\u000a	// detailed once i finish writing the code\u000a\u000a	function toWebM(frames, outputAsArray) {\u000a		var info = checkFrames(frames);\u000a\u000a		//max duration by cluster in milliseconds\u000a		var CLUSTER_MAX_DURATION = 30000;\u000a\u000a		var EBML = [{\u000a			"id": 0x1a45dfa3, // EBML\u000a			"data": [{\u000a				"data": 1,\u000a				"id": 0x4286 // EBMLVersion\u000a			}, {\u000a				"data": 1,\u000a				"id": 0x42f7 // EBMLReadVersion\u000a			}, {\u000a				"data": 4,\u000a				"id": 0x42f2 // EBMLMaxIDLength\u000a			}, {\u000a				"data": 8,\u000a				"id": 0x42f3 // EBMLMaxSizeLength\u000a			}, {\u000a				"data": "webm",\u000a				"id": 0x4282 // DocType\u000a			}, {\u000a				"data": 2,\u000a				"id": 0x4287 // DocTypeVersion\u000a			}, {\u000a				"data": 2,\u000a				"id": 0x4285 // DocTypeReadVersion\u000a			}]\u000a		}, {\u000a			"id": 0x18538067, // Segment\u000a			"data": [{\u000a				"id": 0x1549a966, // Info\u000a				"data": [{\u000a					"data": 1e6, //do things in millisecs (num of nanosecs for duration scale)\u000a					"id": 0x2ad7b1 // TimecodeScale\u000a				}, {\u000a					"data": "whammy",\u000a					"id": 0x4d80 // MuxingApp\u000a				}, {\u000a					"data": "whammy",\u000a					"id": 0x5741 // WritingApp\u000a				}, {\u000a					"data": doubleToString(info.duration),\u000a					"id": 0x4489 // Duration\u000a				}]\u000a			}, {\u000a				"id": 0x1654ae6b, // Tracks\u000a				"data": [{\u000a					"id": 0xae, // TrackEntry\u000a					"data": [{\u000a						"data": 1,\u000a						"id": 0xd7 // TrackNumber\u000a					}, {\u000a						"data": 1,\u000a						"id": 0x73c5 // TrackUID\u000a					}, {\u000a						"data": 0,\u000a						"id": 0x9c // FlagLacing\u000a					}, {\u000a						"data": "und",\u000a						"id": 0x22b59c // Language\u000a					}, {\u000a						"data": "V_VP8",\u000a						"id": 0x86 // CodecID\u000a					}, {\u000a						"data": "VP8",\u000a						"id": 0x258688 // CodecName\u000a					}, {\u000a						"data": 1,\u000a						"id": 0x83 // TrackType\u000a					}, {\u000a						"id": 0xe0, // Video\u000a						"data": [{\u000a							"data": info.width,\u000a							"id": 0xb0 // PixelWidth\u000a						}, {\u000a							"data": info.height,\u000a							"id": 0xba // PixelHeight\u000a						}]\u000a					}]\u000a				}]\u000a			}, {\u000a				"id": 0x1c53bb6b, // Cues\u000a				"data": [\u000a					//cue insertion point\u000a				]\u000a			}\u000a\u000a			//cluster insertion point\u000a			]\u000a		}];\u000a\u000a		var segment = EBML[1];\u000a		var cues = segment.data[2];\u000a\u000a		//Generate clusters (max duration)\u000a		var frameNumber = 0;\u000a		var clusterTimecode = 0;\u000a		while (frameNumber < frames.length) {\u000a\u000a			var cuePoint = {\u000a				"id": 0xbb, // CuePoint\u000a				"data": [{\u000a					"data": Math.round(clusterTimecode),\u000a					"id": 0xb3 // CueTime\u000a				}, {\u000a					"id": 0xb7, // CueTrackPositions\u000a					"data": [{\u000a						"data": 1,\u000a						"id": 0xf7 // CueTrack\u000a					}, {\u000a						"data": 0, // to be filled in when we know it\u000a						"size": 8,\u000a						"id": 0xf1 // CueClusterPosition\u000a					}]\u000a				}]\u000a			};\u000a\u000a			cues.data.push(cuePoint);\u000a\u000a			var clusterFrames = [];\u000a			var clusterDuration = 0;\u000a			do {\u000a				clusterFrames.push(frames[frameNumber]);\u000a				clusterDuration += frames[frameNumber].duration;\u000a				frameNumber++;\u000a			} while (frameNumber < frames.length && clusterDuration < CLUSTER_MAX_DURATION);\u000a\u000a			var clusterCounter = 0;\u000a			var cluster = {\u000a				"id": 0x1f43b675, // Cluster\u000a				"data": [{\u000a					"data": Math.round(clusterTimecode),\u000a					"id": 0xe7 // Timecode\u000a				}].concat(clusterFrames.map(function (webp) {\u000a					var block = makeSimpleBlock({\u000a						discardable: 0,\u000a						frame: webp.data.slice(4),\u000a						invisible: 0,\u000a						keyframe: 1,\u000a						lacing: 0,\u000a						trackNum: 1,\u000a						timecode: Math.round(clusterCounter)\u000a					});\u000a					clusterCounter += webp.duration;\u000a					return {\u000a						data: block,\u000a						id: 0xa3\u000a					};\u000a				}))\u000a			};\u000a\u000a			//Add cluster to segment\u000a			segment.data.push(cluster);\u000a			clusterTimecode += clusterDuration;\u000a		}\u000a\u000a		//First pass to compute cluster positions\u000a		var position = 0;\u000a		for (var i = 0; i < segment.data.length; i++) {\u000a			if (i >= 3) {\u000a				cues.data[i - 3].data[1].data[1].data = position;\u000a			}\u000a			var data = generateEBML([segment.data[i]], outputAsArray);\u000a			position += data.size || data.byteLength || data.length;\u000a			if (i != 2) {\u000a				// not cues\u000a				//Save results to avoid having to encode everything twice\u000a				segment.data[i] = data;\u000a			}\u000a		}\u000a\u000a		return generateEBML(EBML, outputAsArray);\u000a	}\u000a\u000a	// sums the lengths of all the frames and gets the duration, woo\u000a\u000a	function checkFrames(frames) {\u000a		var width = frames[0].width,\u000a		    height = frames[0].height,\u000a		    duration = frames[0].duration;\u000a		for (var i = 1; i < frames.length; i++) {\u000a			if (frames[i].width != width) throw "Frame " + (i + 1) + " has a different width";\u000a			if (frames[i].height != height) throw "Frame " + (i + 1) + " has a different height";\u000a			if (frames[i].duration < 0 || frames[i].duration > 0x7fff) throw "Frame " + (i + 1) + " has a weird duration (must be between 0 and 32767)";\u000a			duration += frames[i].duration;\u000a		}\u000a		return {\u000a			duration: duration,\u000a			width: width,\u000a			height: height\u000a		};\u000a	}\u000a\u000a	function numToBuffer(num) {\u000a		var parts = [];\u000a		while (num > 0) {\u000a			parts.push(num & 0xff);\u000a			num = num >> 8;\u000a		}\u000a		return new Uint8Array(parts.reverse());\u000a	}\u000a\u000a	function numToFixedBuffer(num, size) {\u000a		var parts = new Uint8Array(size);\u000a		for (var i = size - 1; i >= 0; i--) {\u000a			parts[i] = num & 0xff;\u000a			num = num >> 8;\u000a		}\u000a		return parts;\u000a	}\u000a\u000a	function strToBuffer(str) {\u000a		// return new Blob([str]);\u000a\u000a		var arr = new Uint8Array(str.length);\u000a		for (var i = 0; i < str.length; i++) {\u000a			arr[i] = str.charCodeAt(i);\u000a		}\u000a		return arr;\u000a		// this is slower\u000a		// return new Uint8Array(str.split('').map(function(e){\u000a		// 	return e.charCodeAt(0)\u000a		// }))\u000a	}\u000a\u000a	//sorry this is ugly, and sort of hard to understand exactly why this was done\u000a	// at all really, but the reason is that there's some code below that i dont really\u000a	// feel like understanding, and this is easier than using my brain.\u000a\u000a	function bitsToBuffer(bits) {\u000a		var data = [];\u000a		var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join('0') : '';\u000a		bits = pad + bits;\u000a		for (var i = 0; i < bits.length; i += 8) {\u000a			data.push(parseInt(bits.substr(i, 8), 2));\u000a		}\u000a		return new Uint8Array(data);\u000a	}\u000a\u000a	function generateEBML(json, outputAsArray) {\u000a		var ebml = [];\u000a		for (var i = 0; i < json.length; i++) {\u000a			if (!('id' in json[i])) {\u000a				//already encoded blob or byteArray\u000a				ebml.push(json[i]);\u000a				continue;\u000a			}\u000a\u000a			var data = json[i].data;\u000a			if (typeof data == 'object') data = generateEBML(data, outputAsArray);\u000a			if (typeof data == 'number') data = 'size' in json[i] ? numToFixedBuffer(data, json[i].size) : bitsToBuffer(data.toString(2));\u000a			if (typeof data == 'string') data = strToBuffer(data);\u000a\u000a			if (data.length) {\u000a				var z = z;\u000a			}\u000a\u000a			var len = data.size || data.byteLength || data.length;\u000a			var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\u000a			var size_str = len.toString(2);\u000a			var padded = new Array(zeroes * 7 + 7 + 1 - size_str.length).join('0') + size_str;\u000a			var size = new Array(zeroes).join('0') + '1' + padded;\u000a\u000a			//i actually dont quite understand what went on up there, so I'm not really\u000a			//going to fix this, i'm probably just going to write some hacky thing which\u000a			//converts that string into a buffer-esque thing\u000a\u000a			ebml.push(numToBuffer(json[i].id));\u000a			ebml.push(bitsToBuffer(size));\u000a			ebml.push(data);\u000a		}\u000a\u000a		//output as blob or byteArray\u000a		if (outputAsArray) {\u000a			//convert ebml to an array\u000a			var buffer = toFlatArray(ebml);\u000a			return new Uint8Array(buffer);\u000a		} else {\u000a			return new Blob(ebml, { type: "video/webm" });\u000a		}\u000a	}\u000a\u000a	function toFlatArray(arr, outBuffer) {\u000a		if (outBuffer == null) {\u000a			outBuffer = [];\u000a		}\u000a		for (var i = 0; i < arr.length; i++) {\u000a			if (typeof arr[i] == 'object') {\u000a				//an array\u000a				toFlatArray(arr[i], outBuffer);\u000a			} else {\u000a				//a simple element\u000a				outBuffer.push(arr[i]);\u000a			}\u000a		}\u000a		return outBuffer;\u000a	}\u000a\u000a	//OKAY, so the following two functions are the string-based old stuff, the reason they're\u000a	//still sort of in here, is that they're actually faster than the new blob stuff because\u000a	//getAsFile isn't widely implemented, or at least, it doesn't work in chrome, which is the\u000a	// only browser which supports get as webp\u000a\u000a	//Converting between a string of 0010101001's and binary back and forth is probably inefficient\u000a	//TODO: get rid of this function\u000a	function toBinStr_old(bits) {\u000a		var data = '';\u000a		var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join('0') : '';\u000a		bits = pad + bits;\u000a		for (var i = 0; i < bits.length; i += 8) {\u000a			data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\u000a		}\u000a		return data;\u000a	}\u000a\u000a	function generateEBML_old(json) {\u000a		var ebml = '';\u000a		for (var i = 0; i < json.length; i++) {\u000a			var data = json[i].data;\u000a			if (typeof data == 'object') data = generateEBML_old(data);\u000a			if (typeof data == 'number') data = toBinStr_old(data.toString(2));\u000a\u000a			var len = data.length;\u000a			var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\u000a			var size_str = len.toString(2);\u000a			var padded = new Array(zeroes * 7 + 7 + 1 - size_str.length).join('0') + size_str;\u000a			var size = new Array(zeroes).join('0') + '1' + padded;\u000a\u000a			ebml += toBinStr_old(json[i].id.toString(2)) + toBinStr_old(size) + data;\u000a		}\u000a		return ebml;\u000a	}\u000a\u000a	//woot, a function that's actually written for this project!\u000a	//this parses some json markup and makes it into that binary magic\u000a	//which can then get shoved into the matroska comtainer (peaceably)\u000a\u000a	function makeSimpleBlock(data) {\u000a		var flags = 0;\u000a		if (data.keyframe) flags |= 128;\u000a		if (data.invisible) flags |= 8;\u000a		if (data.lacing) flags |= data.lacing << 1;\u000a		if (data.discardable) flags |= 1;\u000a		if (data.trackNum > 127) {\u000a			throw "TrackNumber > 127 not supported";\u000a		}\u000a		var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function (e) {\u000a			return String.fromCharCode(e);\u000a		}).join('') + data.frame;\u000a\u000a		return out;\u000a	}\u000a\u000a	// here's something else taken verbatim from weppy, awesome rite?\u000a\u000a	function parseWebP(riff) {\u000a		var VP8 = riff.RIFF[0].WEBP[0];\u000a\u000a		var frame_start = VP8.indexOf('\u005cx9d\u005cx01\u005cx2a'); //A VP8 keyframe starts with the 0x9d012a header\u000a		for (var i = 0, c = []; i < 4; i++) c[i] = VP8.charCodeAt(frame_start + 3 + i);\u000a\u000a		var width, horizontal_scale, height, vertical_scale, tmp;\u000a\u000a		//the code below is literally copied verbatim from the bitstream spec\u000a		tmp = c[1] << 8 | c[0];\u000a		width = tmp & 0x3FFF;\u000a		horizontal_scale = tmp >> 14;\u000a		tmp = c[3] << 8 | c[2];\u000a		height = tmp & 0x3FFF;\u000a		vertical_scale = tmp >> 14;\u000a		return {\u000a			width: width,\u000a			height: height,\u000a			data: VP8,\u000a			riff: riff\u000a		};\u000a	}\u000a\u000a	// i think i'm going off on a riff by pretending this is some known\u000a	// idiom which i'm making a casual and brilliant pun about, but since\u000a	// i can't find anything on google which conforms to this idiomatic\u000a	// usage, I'm assuming this is just a consequence of some psychotic\u000a	// break which makes me make up puns. well, enough riff-raff (aha a\u000a	// rescue of sorts), this function was ripped wholesale from weppy\u000a\u000a	function parseRIFF(string) {\u000a		var offset = 0;\u000a		var chunks = {};\u000a\u000a		while (offset < string.length) {\u000a			var id = string.substr(offset, 4);\u000a			chunks[id] = chunks[id] || [];\u000a			if (id == 'RIFF' || id == 'LIST') {\u000a				var len = parseInt(string.substr(offset + 4, 4).split('').map(function (i) {\u000a					var unpadded = i.charCodeAt(0).toString(2);\u000a					return new Array(8 - unpadded.length + 1).join('0') + unpadded;\u000a				}).join(''), 2);\u000a				var data = string.substr(offset + 4 + 4, len);\u000a				offset += 4 + 4 + len;\u000a				chunks[id].push(parseRIFF(data));\u000a			} else if (id == 'WEBP') {\u000a				// Use (offset + 8) to skip past "VP8 "/"VP8L"/"VP8X" field after "WEBP"\u000a				chunks[id].push(string.substr(offset + 8));\u000a				offset = string.length;\u000a			} else {\u000a				// Unknown chunk type; push entire payload\u000a				chunks[id].push(string.substr(offset + 4));\u000a				offset = string.length;\u000a			}\u000a		}\u000a		return chunks;\u000a	}\u000a\u000a	// here's a little utility function that acts as a utility for other functions\u000a	// basically, the only purpose is for encoding "Duration", which is encoded as\u000a	// a double (considerably more difficult to encode than an integer)\u000a	function doubleToString(num) {\u000a		return [].slice.call(new Uint8Array(new Float64Array([num]) //create a float64 array\u000a		.buffer) //extract the array buffer\u000a		, 0) // convert the Uint8Array into a regular array\u000a		.map(function (e) {\u000a			//since it's a regular array, we can now use map\u000a			return String.fromCharCode(e); // encode all the bytes individually\u000a		}).reverse() //correct the byte endianness (assume it's little endian for now)\u000a		.join(''); // join the bytes in holy matrimony as a string\u000a	}\u000a\u000a	function WhammyVideo(speed, quality) {\u000a		// a more abstract-ish API\u000a		this.frames = [];\u000a		this.duration = 1000 / speed;\u000a		this.quality = quality || 0.8;\u000a	}\u000a\u000a	WhammyVideo.prototype.add = function (frame, duration) {\u000a		if (typeof duration != 'undefined' && this.duration) throw "you can't pass a duration if the fps is set";\u000a		if (typeof duration == 'undefined' && !this.duration) throw "if you don't have the fps set, you need to have durations here.";\u000a		if (frame.canvas) {\u000a			//CanvasRenderingContext2D\u000a			frame = frame.canvas;\u000a		}\u000a		if (frame.toDataURL) {\u000a			// frame = frame.toDataURL('image/webp', this.quality);\u000a			// quickly store image data so we don't block cpu. encode in compile method.\u000a			frame = frame.getContext('2d').getImageData(0, 0, frame.width, frame.height);\u000a		} else if (typeof frame != "string") {\u000a			throw "frame must be a a HTMLCanvasElement, a CanvasRenderingContext2D or a DataURI formatted string";\u000a		}\u000a		if (typeof frame === "string" && !/^data:image\u005c/webp;base64,/ig.test(frame)) {\u000a			throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";\u000a		}\u000a		this.frames.push({\u000a			image: frame,\u000a			duration: duration || this.duration\u000a		});\u000a	};\u000a\u000a	// deferred webp encoding. Draws image data to canvas, then encodes as dataUrl\u000a	WhammyVideo.prototype.encodeFrames = function (callback) {\u000a\u000a		if (this.frames[0].image instanceof ImageData) {\u000a\u000a			var frames = this.frames;\u000a			var tmpCanvas = document.createElement('canvas');\u000a			var tmpContext = tmpCanvas.getContext('2d');\u000a			tmpCanvas.width = this.frames[0].image.width;\u000a			tmpCanvas.height = this.frames[0].image.height;\u000a\u000a			var encodeFrame = function (index) {\u000a				console.log('encodeFrame', index);\u000a				var frame = frames[index];\u000a				tmpContext.putImageData(frame.image, 0, 0);\u000a				frame.image = tmpCanvas.toDataURL('image/webp', this.quality);\u000a				if (index < frames.length - 1) {\u000a					setTimeout(function () {\u000a						encodeFrame(index + 1);\u000a					}, 1);\u000a				} else {\u000a					callback();\u000a				}\u000a			}.bind(this);\u000a\u000a			encodeFrame(0);\u000a		} else {\u000a			callback();\u000a		}\u000a	};\u000a\u000a	WhammyVideo.prototype.compile = function (outputAsArray, callback) {\u000a\u000a		this.encodeFrames(function () {\u000a\u000a			var webm = new toWebM(this.frames.map(function (frame) {\u000a				var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\u000a				webp.duration = frame.duration;\u000a				return webp;\u000a			}), outputAsArray);\u000a			callback(webm);\u000a		}.bind(this));\u000a	};\u000a\u000a	return {\u000a		Video: WhammyVideo,\u000a		fromImageArray: function (images, fps, outputAsArray) {\u000a			return toWebM(images.map(function (image) {\u000a				var webp = parseWebP(parseRIFF(atob(image.slice(23))));\u000a				webp.duration = 1000 / fps;\u000a				return webp;\u000a			}), outputAsArray);\u000a		},\u000a		toWebM: toWebM\u000a		// expose methods of madness\u000a	};\u000a}();\u000a\u000a
p1
.