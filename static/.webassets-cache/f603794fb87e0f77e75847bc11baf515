Vfunction hhmmss(secs) {\u000a    return new Date(secs * 1000).toISOString().substr(11, 8);\u000a}\u000a\u000afunction img(url, w = 20, h = 20, alt = "") {\u000a    return `<img src=${url} width=${w}px height=${h}px class="img-fluid" alt="${alt}">`;\u000a}\u000a\u000a// return an HTML href tag from a url and text\u000afunction href(url, text) {\u000a    return `<a href='${url}' target='_blank'>${text}</a>`;\u000a}\u000a\u000afunction ip_lookup_url(ip) {\u000a    return ip ? "http://freegeoip.net/json/" + ip : "#";\u000a}\u000a\u000a// Strava specific stuff\u000afunction stravaActivityURL(id) {\u000a    return "https://www.strava.com/activities/" + id;\u000a}\u000a\u000afunction stravaAthleteURL(id) {\u000a    return "https://www.strava.com/athletes/" + id;\u000a}\u000a// ----------------------\u000a\u000a\u000a// For DataTables\u000afunction formatDate(data, type, row, meta) {\u000a    date = new Date(data);\u000a    return type === "display" || type === "filter" ? date.toLocaleString("en-US", { hour12: false }) : date;\u000a}\u000a\u000afunction formatIP(data, type, row, meta) {\u000a    if (data) {\u000a        let ip = data;\u000a        return type === "display" ? href(ip_lookup_url(ip), ip) : ip;\u000a    } else {\u000a        return "";\u000a    }\u000a}\u000a\u000afunction formatUserId(data, type, row) {\u000a    if (data) {\u000a        if (type == "display") {\u000a            return href("/" + data, img(row.profile, w = 40, h = 40, alt = data));\u000a        } else {\u000a            return data;\u000a        }\u000a    } else {\u000a        return "";\u000a    }\u000a}\u000a// ------------------------\u000a\u000a\u000a// Fetching stuff using "ajax"\u000afunction httpGetAsync(theUrl, callback) {\u000a    let xmlHttp = new XMLHttpRequest();\u000a    xmlHttp.onreadystatechange = function () {\u000a        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) callback(xmlHttp.responseText);\u000a    };\u000a    xmlHttp.open("GET", theUrl, true); // true for asynchronous\u000a    xmlHttp.send(null);\u000a}\u000a\u000a// decode a (possibly RLE-encoded) array of successive differences into\u000a//  an array of the original values\u000a//  This will decode both [1, 2,2,2,2,2,2, 5] and [1, [2,6], 5] into\u000a//    [0, 1, 3, 5, 7, 9, 11, 13, 18]\u000afunction streamDecode(rle_list, first_value = 0) {\u000a    let running_sum = first_value,\u000a        outArray = [first_value],\u000a        len = rle_list.length;\u000a    for (let i = 0; i < len; i++) {\u000a        el = rle_list[i];\u000a        if (el instanceof Array) {\u000a            for (let j = 0; j < el[1]; j++) {\u000a                running_sum += el[0];\u000a                outArray.push(running_sum);\u000a            }\u000a        } else {\u000a            running_sum += el;\u000a            outArray.push(running_sum);\u000a        }\u000a    }\u000a    return outArray;\u000a}\u000a\u000a
p1
.